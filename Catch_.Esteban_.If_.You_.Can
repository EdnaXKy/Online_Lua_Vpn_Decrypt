
-----------------------------------------------------------------------------------------------------
-- 𝐑𝐞𝐬𝐩𝐞𝐜𝐭 𝐂𝐫𝐞𝐚𝐭𝐨𝐫𝐬. 𝐃𝐨𝐧'𝐭 𝐑𝐞𝐦𝐨𝐯𝐞 𝐂𝐫𝐞𝐝𝐢𝐭 𝐌𝐨𝐝𝐮𝐥𝐞𝐬..!!
-- 𝐂𝐨𝐝𝐞𝐝 𝐁𝐲 : 𝐄𝐒𝐓𝐄𝐁𝐀𝐍_𝐙𝐗𝐗
-----------------------------------------------------------------------------------------------------

gg.getTargetInfo(packageName)
gg.toast("✔ 𝐒𝐜𝐫𝐢𝐩𝐭 𝐀𝐜𝐭𝐢𝐯𝐞𝐝")
gg.setVisible(false)
gg.sleep(200)
gg.clearResults()
gg.setVisible(true)

-----------------------------------------------------------------------------------------------------
-- 𝐑𝐞𝐬𝐩𝐞𝐜𝐭 𝐂𝐫𝐞𝐚𝐭𝐨𝐫𝐬. 𝐃𝐨𝐧'𝐭 𝐑𝐞𝐦𝐨𝐯𝐞 𝐂𝐫𝐞𝐝𝐢𝐭 𝐌𝐨𝐝𝐮𝐥𝐞𝐬..!!
-- 𝐂𝐨𝐝𝐞𝐝 𝐁𝐲 : 𝐄𝐒𝐓𝐄𝐁𝐀𝐍_𝐙𝐗𝐗
-----------------------------------------------------------------------------------------------------

function Irene()
  Menu = gg.choice({
    "〘 ❖ 〙  ➣   ⧼  𝐇𝐓𝐓𝐏 𝐂𝐮𝐬𝐭𝐨𝐦  ⧽", -- 1
    "〘 ❖ 〙  ➣   ⧼  𝐇𝐓𝐓𝐏 𝐈𝐧𝐣𝐞𝐜𝐭𝐨𝐫  ⧽", -- 2
    "〘 ❖ 〙  ➣   ⧼  𝐓𝐋𝐒 𝐓𝐮𝐧𝐧𝐞𝐥  ⧽", -- 3
    "〘 ❖ 〙  ➣   ⧼  𝐍𝐏𝐕𝟒 𝐌𝐞𝐧𝐮  ⧽", -- 4
    "〘 ❖ 〙  ➣   ⧼  𝐃𝐚𝐫𝐤 𝐓𝐮𝐧𝐧𝐞𝐥  ⧽", -- 5
    "〘 ❖ 〙  ➣   ⧼  Manual Dump  ⧽", -- 5
    "〘 ❖ 〙  ➣   ⧼  𝐂𝐫𝐞𝐝𝐢𝐭 𝐌𝐨𝐝𝐮𝐥𝐞𝐬  ⧽", -- 5
    "〘 ✖ 〙  ➣   ⧼  𝐄𝐱𝐢𝐭 𝐒𝐜𝐫𝐢𝐩𝐭  ⧽" -- 7
}, nil, os.date(
"────────────────────────────\n███████╗  ██╗░░██╗  ██╗░░██╗\n╚════██║  ╚██╗██╔╝  ╚██╗██╔╝\n░░███╔═╝  ░╚███╔╝░  ░╚███╔╝░\n██╔══╝░░  ░██╔██╗░  ░██╔██╗░\n███████╗  ██╔╝╚██╗  ██╔╝╚██╗\n╚══════╝  ╚═╝░░╚═╝  ╚═╝░░╚═╝\n────────────────────────────\n⋆ 𝐙𝐗𝐗 • 𝐃𝐄𝐂𝐑𝐘𝐏𝐓𝐎𝐑 𝐓𝐎𝐎𝐋𝐒\n⋆ 𝐒𝐜𝐫𝐢𝐩𝐭 𝐕𝐞𝐫𝐬𝐢𝐨𝐧〚 𝟏.𝟎.𝟎 𝐁𝐞𝐭𝐚𝐓𝐞𝐬𝐭 〛\n⋆ 𝐂𝐨𝐝𝐞𝐝 𝐁𝐲 : 𝐄𝐒𝐓𝐄𝐁𝐀𝐍_𝐙𝐗𝐗 - 𝐊𝐌𝐊𝐙 𝟏𝟎𝟏 𖠙 ᯓ\n────────────────────────────\n"
))

-----------------------------------------------------------------------------------------------------
-- 𝐑𝐞𝐬𝐩𝐞𝐜𝐭 𝐂𝐫𝐞𝐚𝐭𝐨𝐫𝐬. 𝐃𝐨𝐧'𝐭 𝐑𝐞𝐦𝐨𝐯𝐞 𝐂𝐫𝐞𝐝𝐢𝐭 𝐌𝐨𝐝𝐮𝐥𝐞𝐬..!!
-- 𝐂𝐨𝐝𝐞𝐝 𝐁𝐲 : 𝐄𝐒𝐓𝐄𝐁𝐀𝐍_𝐙𝐗𝐗
-----------------------------------------------------------------------------------------------------

if Menu == nil then
else
if Menu == 1 then
HTTPCustom()
end
if Menu == 2 then
HTTPInjector()
end
if Menu == 3 then
TlsTunnel()
end
if Menu == 4 then
NPV4Menu()
end
if Menu == 5 then
DarkTunnel()
end
if Menu == 6 then
ManualDump()
end
if Menu == 7 then
CreditModules()
end
if Menu == 8 then
ExitScript()
end
end
Lua = -1
end

-----------------------------------------------------------------------------------------------------
-- 𝐑𝐞𝐬𝐩𝐞𝐜𝐭 𝐂𝐫𝐞𝐚𝐭𝐨𝐫𝐬. 𝐃𝐨𝐧'𝐭 𝐑𝐞𝐦𝐨𝐯𝐞 𝐂𝐫𝐞𝐝𝐢𝐭 𝐌𝐨𝐝𝐮𝐥𝐞𝐬..!!
-- 𝐂𝐨𝐝𝐞𝐝 𝐁𝐲 : 𝐄𝐒𝐓𝐄𝐁𝐀𝐍_𝐙𝐗𝐗
-----------------------------------------------------------------------------------------------------

function HTTPCustom()
  HC = gg.choice({
    "〘 ❖ 〙  ➣   ⧼  𝐁𝐲𝐩𝐚𝐬𝐬 𝐏𝐚𝐬𝐬𝐰𝐨𝐫𝐝  ⧽",
    "〘 ❖ 〙  ➣   ⧼  𝐀𝐮𝐭𝐨𝐏𝐫𝐢𝐧𝐭 𝐈  ⧽",
    "〘 ❖ 〙  ➣   ⧼  𝐃𝐞𝐜𝐫𝐲𝐩𝐭 𝐈  ⧽",
    "〘 ❖ 〙  ➣   ⧼  𝐃𝐞𝐜𝐫𝐲𝐩𝐭 𝐈𝐈  ⧽",
    "〘 ❖ 〙  ➣   ⧼  𝐏𝐬𝐢𝐩𝐡𝐨𝐧 𝐀𝐮𝐭𝐡𝐨𝐫𝐢𝐳𝐨𝐧  ⧽",
    "〘 ✖ 〙  ➣   ⧼  𝐁𝐚𝐜𝐤  ⧽"
}, nil, os.date(
"────────────────────────────\n███████╗██╗░░██╗██╗░░██╗\n╚════██║╚██╗██╔╝╚██╗██╔╝\n░░███╔═╝░╚███╔╝░░╚███╔╝\n██╔══╝░░░██╔██╗░░██╔██╗\n███████╗██╔╝╚██╗██╔╝╚██╗\n╚══════╝╚═╝░░╚═╝╚═╝░░╚═╝\n────────────────────────────\n⋆ 𝐇𝐂 𝐓𝐨𝐨𝐥𝐬 𝐃𝐞𝐜𝐫𝐲𝐩𝐭𝐨𝐫\n⋆ 𝐕𝐞𝐫𝐬𝐢𝐨𝐧〚 𝟑.𝟎 〛\n⋆ 𝐂𝐨𝐝𝐞𝐝 𝐁𝐲 : 𝐄𝐒𝐓𝐄𝐁𝐀𝐍_𝐙𝐗𝐗 - 𝐊𝐌𝐊𝐙 𝟏𝟎𝟏 𖠙 ᯓ\n"
))

-----------------------------------------------------------------------------------------------------
-- 𝐑𝐞𝐬𝐩𝐞𝐜𝐭 𝐂𝐫𝐞𝐚𝐭𝐨𝐫𝐬. 𝐃𝐨𝐧'𝐭 𝐑𝐞𝐦𝐨𝐯𝐞 𝐂𝐫𝐞𝐝𝐢𝐭 𝐌𝐨𝐝𝐮𝐥𝐞𝐬..!!
-- 𝐂𝐨𝐝𝐞𝐝 𝐁𝐲 : 𝐄𝐒𝐓𝐄𝐁𝐀𝐍_𝐙𝐗𝐗
-----------------------------------------------------------------------------------------------------

if HC == nil then
else
if HC == 1 then
BypassPassword()
end
if HC == 2 then
AutoPrintI()
end
if HC == 3 then
DecI()
end
if HC == 4 then
DecII()
end
if HC == 5 then
PsiphonAuth()
end
if HC == 6 then
Irene()
end
end
Lua = -1
end

-----------------------------------------------------------------------------------------------------
-- 𝐑𝐞𝐬𝐩𝐞𝐜𝐭 𝐂𝐫𝐞𝐚𝐭𝐨𝐫𝐬. 𝐃𝐨𝐧'𝐭 𝐑𝐞𝐦𝐨𝐯𝐞 𝐂𝐫𝐞𝐝𝐢𝐭 𝐌𝐨𝐝𝐮𝐥𝐞𝐬..!!
-- 𝐂𝐨𝐝𝐞𝐝 𝐁𝐲 : 𝐄𝐒𝐓𝐄𝐁𝐀𝐍_𝐙𝐗𝐗
-----------------------------------------------------------------------------------------------------

function NPV4Menu()
  NPV4 = gg.choice({
    "〘 ❖ 〙  ➣   ⧼  𝐃𝐞𝐜𝐫𝐲𝐩𝐭 𝐍𝐚𝐩𝐬𝐭𝐞𝐫𝐧𝐞𝐭𝐕  ⧽",
    "〘 ❖ 〙  ➣   ⧼  𝐑𝐞𝐬𝐮𝐥𝐭 𝐍𝐚𝐩𝐬𝐭𝐞𝐫𝐧𝐞𝐭𝐕  ⧽",
    "〘 ✖ 〙  ➣   ⧼  𝐁𝐚𝐜𝐤  ⧽"
}, nil, os.date(
"────────────────────────────\n███████╗██╗░░██╗██╗░░██╗\n╚════██║╚██╗██╔╝╚██╗██╔╝\n░░███╔═╝░╚███╔╝░░╚███╔╝\n██╔══╝░░░██╔██╗░░██╔██╗\n███████╗██╔╝╚██╗██╔╝╚██╗\n╚══════╝╚═╝░░╚═╝╚═╝░░╚═╝\n────────────────────────────\n⋆ 𝐍𝐏𝐕𝟒 𝐓𝐨𝐨𝐥𝐬 𝐃𝐞𝐜𝐫𝐲𝐩𝐭𝐨𝐫\n⋆ 𝐕𝐞𝐫𝐬𝐢𝐨𝐧〚 𝟏.𝟐 〛\n⋆ 𝐂𝐨𝐝𝐞𝐝 𝐁𝐲 : 𝐄𝐒𝐓𝐄𝐁𝐀𝐍_𝐙𝐗𝐗 - 𝐊𝐌𝐊𝐙 𝟏𝟎𝟏 𖠙 ᯓ\n"
))

if NPV4 == nil then
else
if NPV4 == 1 then
NapsternetV()
end
if NPV4 == 2 then
ResultNapsternetV()
end
if NPV4 == 3 then
Irene()
end
end
Lua = -1
end
-----------------------------------------------------------------------------------------------------
-- 𝐑𝐞𝐬𝐩𝐞𝐜𝐭 𝐂𝐫𝐞𝐚𝐭𝐨𝐫𝐬. 𝐃𝐨𝐧'𝐭 𝐑𝐞𝐦𝐨𝐯𝐞 𝐂𝐫𝐞𝐝𝐢𝐭 𝐌𝐨𝐝𝐮𝐥𝐞𝐬..!!
-- 𝐂𝐨𝐝𝐞𝐝 𝐁𝐲 : 𝐄𝐒𝐓𝐄𝐁𝐀𝐍_𝐙𝐗𝐗
-----------------------------------------------------------------------------------------------------

limit = false
function rwmem(Address, SizeOrBuffer)
	assert(Address ~= nil, "[rwmem]: error, provided address is nil.")
	_rw = {}
	if type(SizeOrBuffer) == "number" then
		_ = ""
		for _ = 1, SizeOrBuffer do _rw[_] = {address = (Address - 1) + _, flags = gg.TYPE_BYTE} end
		for v, __ in ipairs(gg.getValues(_rw)) do
		  if __.value == 00 and limit == true then
		    return _
		  end
		  _ = _ .. string.format("%02X", __.value & 0xFF)
		  -- payload = payload .. string.char(__.value)
        end
		return _
	end
	Byte = {} SizeOrBuffer:gsub("..", function(x) 
		Byte[#Byte + 1] = x _rw[#Byte] = {address = (Address - 1) + #Byte, flags = gg.TYPE_BYTE, value = x .. "h"} 
	end)
	gg.setValues(_rw)
end

function hexdecode(hex)
   return (hex:gsub("%x%x", function(digits) return string.char(tonumber(digits, 16)) end))
end

function hexencode(str)
   return (str:gsub(".", function(char) return string.format("%2x", char:byte()) end))
end

function Dec2Hex(nValue)
	nHexVal = string.format("%X", nValue);
	sHexVal = nHexVal.."";
	return sHexVal;
end

function ToInteger(number)
    return math.floor(tonumber(number) or error("Could not cast '" .. tostring(number) .. "' to number.'"))
end

-----------------------------------------------------------------------------------------------------
-- 𝐑𝐞𝐬𝐩𝐞𝐜𝐭 𝐂𝐫𝐞𝐚𝐭𝐨𝐫𝐬. 𝐃𝐨𝐧'𝐭 𝐑𝐞𝐦𝐨𝐯𝐞 𝐂𝐫𝐞𝐝𝐢𝐭 𝐌𝐨𝐝𝐮𝐥𝐞𝐬..!!
-- 𝐂𝐨𝐝𝐞𝐝 𝐁𝐲 : 𝐄𝐒𝐓𝐄𝐁𝐀𝐍_𝐙𝐗𝐗
-----------------------------------------------------------------------------------------------------

function DecI()
function save(data)
    io.open(gg.EXT_STORAGE .. "/decrypt.txt", "w"):write(hexdecode(data))
    gg.toast("✓ 𝐃𝐞𝐜𝐫𝐲𝐩𝐭 𝐒𝐮𝐜𝐜𝐞𝐬𝐬𝐟𝐮𝐥")
    gg.alert("╔══╗─────────╔╗\n╚╗╗╠═╦═╦╦╦╦╦═╣╚╗\n╔╩╝║╩╣═╣╔╣║║╬║╔╣\n╚══╩═╩═╩╝╠╗║╔╩═╝\n─────────╚═╩╝\n╔══╗───────╔═╦═╗\n║══╬╦╦═╦═╦═╣═╣═╬╦╦╗╔╗\n╠══║║║═╣═╣╩╬═║╔╣║║╚╣╚╗\n╚══╩═╩═╩═╩═╩═╩╝╚═╩═╩═╝", "𝘽𝙖𝙘𝙠 𝙈𝙚𝙣𝙪")
    end

    gg.setRanges(gg.REGION_JAVA_HEAP)
    gg.searchNumber("h5b 63 72 6c 66 5d 5b 63 72 6c 66 5d", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
        gg.toast("✘ 𝐌𝐞𝐭𝐡𝐨𝐝 𝟏 𝐅𝐚𝐢𝐥𝐞𝐝")
        hc_method2 = true
        end
    
    
    if hc_method2 then
        gg.searchNumber("h69 6e 62 6f 75 6e 64 73", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
        local r = gg.getResults(1)
        if #r < 1 then
            gg.toast("✘ 𝐌𝐞𝐭𝐡𝐨𝐝 𝟐 𝐅𝐚𝐢𝐥𝐞𝐝")
            hc_method3 = true
            end
            end
    
   
    if hc_method3 then
        gg.searchNumber("h3a 55 70 67 72 61 64 65 3a 20 77 65 62 73 6f 63 6b 65 74", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
        local r = gg.getResults(1)
        if #r < 1 then
            gg.toast("✘ 𝐌𝐞𝐭𝐡𝐨𝐝 𝟑 𝐅𝐚𝐢𝐥𝐞𝐝")
            hc_method4 = true
            end
            end
    
  
    if hc_method4 then
        gg.searchNumber("h5b 73 70 6c 69 74 50 73 69 70 68 6f 6e 5d", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
        local r = gg.getResults(1)
        if #r < 1 then
            gg.toast("✘ 𝐌𝐞𝐭𝐡𝐨𝐝 𝟒 𝐅𝐚𝐢𝐥𝐞𝐝")
            hc_method5 = true
            end
            end
    
    if hc_method5 then
        gg.toast("✘ 𝐃𝐞𝐜𝐫𝐲𝐩𝐭 𝐅𝐚𝐢𝐥𝐞𝐝")
        return (Menu)
        end
        
   
    
    local r = gg.getResults(1)
    if limit == false then
        r[1].address = r[1].address - 8000
        end
    
    readedMem = rwmem(r[1].address, 50000)
    save(readedMem)
    gg.clearResults()
    end

-----------------------------------------------------------------------------------------------------
-- 𝐑𝐞𝐬𝐩𝐞𝐜𝐭 𝐂𝐫𝐞𝐚𝐭𝐨𝐫𝐬. 𝐃𝐨𝐧'𝐭 𝐑𝐞𝐦𝐨𝐯𝐞 𝐂𝐫𝐞𝐝𝐢𝐭 𝐌𝐨𝐝𝐮𝐥𝐞𝐬..!!
-- 𝐂𝐨𝐝𝐞𝐝 𝐁𝐲 : 𝐄𝐒𝐓𝐄𝐁𝐀𝐍_𝐙𝐗𝐗
-----------------------------------------------------------------------------------------------------

function DecII()
function save(data)
    io.open(gg.EXT_STORAGE .. "/decrypt.txt", "w"):write(hexdecode(data))
    gg.toast("✓ 𝐃𝐞𝐜𝐫𝐲𝐩𝐭 𝐒𝐮𝐜𝐜𝐞𝐬𝐬𝐟𝐮𝐥")
    gg.alert("╔══╗─────────╔╗\n╚╗╗╠═╦═╦╦╦╦╦═╣╚╗\n╔╩╝║╩╣═╣╔╣║║╬║╔╣\n╚══╩═╩═╩╝╠╗║╔╩═╝\n─────────╚═╩╝\n╔══╗───────╔═╦═╗\n║══╬╦╦═╦═╦═╣═╣═╬╦╦╗╔╗\n╠══║║║═╣═╣╩╬═║╔╣║║╚╣╚╗\n╚══╩═╩═╩═╩═╩═╩╝╚═╩═╩═╝", "𝘽𝙖𝙘𝙠 𝙈𝙚𝙣𝙪")
    end

    gg.setRanges(gg.REGION_JAVA_HEAP)
    gg.searchNumber("h22 63 66 67 22 3a 20 7b", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
        gg.toast("✘ 𝐌𝐞𝐭𝐡𝐨𝐝 𝟏 𝐅𝐚𝐢𝐥𝐞𝐝")
        hc_method2 = true
        end
    
    
    if hc_method2 then
        gg.searchNumber("h22 76 65 72 43 66 67 22 3a", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
        local r = gg.getResults(1)
        if #r < 1 then
            gg.toast("✘ 𝐌𝐞𝐭𝐡𝐨𝐝 𝟐 𝐅𝐚𝐢𝐥𝐞𝐝")
            hc_method3 = true
            end
            end
    
   
    if hc_method3 then
        gg.searchNumber("h22 61 22 3a", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
        local r = gg.getResults(1)
        if #r < 1 then
            gg.toast("✘ 𝐌𝐞𝐭𝐡𝐨𝐝 𝟑 𝐅𝐚𝐢𝐥𝐞𝐝")
            hc_method4 = true
            end
            end
    

    if hc_method4 then
        gg.toast("✘ 𝐃𝐞𝐜𝐫𝐲𝐩𝐭 𝐅𝐚𝐢𝐥𝐞𝐝")
        return (Menu)
        end
        
   
    
local r = gg.getResults(1000)
  if limit == true then
    r[1].address = r[1].address - 8192
  end
  readedMem = rwmem(r[1].address, 30000)
  save(readedMem)
  gg.clearResults()
end

-----------------------------------------------------------------------------------------------------
-- 𝐑𝐞𝐬𝐩𝐞𝐜𝐭 𝐂𝐫𝐞𝐚𝐭𝐨𝐫𝐬. 𝐃𝐨𝐧'𝐭 𝐑𝐞𝐦𝐨𝐯𝐞 𝐂𝐫𝐞𝐝𝐢𝐭 𝐌𝐨𝐝𝐮𝐥𝐞𝐬..!!
-- 𝐂𝐨𝐝𝐞𝐝 𝐁𝐲 : 𝐄𝐒𝐓𝐄𝐁𝐀𝐍_𝐙𝐗𝐗
-----------------------------------------------------------------------------------------------------

function PsiphonAuth()
function save(data)
    io.open(gg.EXT_STORAGE .. "/decrypt.txt", "w"):write(hexdecode(data))
    gg.toast("✓ 𝐃𝐞𝐜𝐫𝐲𝐩𝐭 𝐒𝐮𝐜𝐜𝐞𝐬𝐬𝐟𝐮𝐥")
    gg.alert("╔══╗─────────╔╗\n╚╗╗╠═╦═╦╦╦╦╦═╣╚╗\n╔╩╝║╩╣═╣╔╣║║╬║╔╣\n╚══╩═╩═╩╝╠╗║╔╩═╝\n─────────╚═╩╝\n╔══╗───────╔═╦═╗\n║══╬╦╦═╦═╦═╣═╣═╬╦╦╗╔╗\n╠══║║║═╣═╣╩╬═║╔╣║║╚╣╚╗\n╚══╩═╩═╩═╩═╩═╩╝╚═╩═╩═╝", "𝘽𝙖𝙘𝙠 𝙈𝙚𝙣𝙪")
    end

    gg.setRanges(gg.REGION_JAVA_HEAP)
    gg.searchNumber("h65 79 4a 42 64 58 52 6f 62 33 4a 70 65 6d 46 30 61 57 39 75 49 6a 70", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
        gg.toast("✘ 𝐌𝐞𝐭𝐡𝐨𝐝 𝟏 𝐅𝐚𝐢𝐥𝐞𝐝")
        hc_method2 = true
        end
    
    
    if hc_method2 then
        gg.toast("✘ 𝐃𝐞𝐜𝐫𝐲𝐩𝐭 𝐅𝐚𝐢𝐥𝐞𝐝")
        return (HC)
        end
        
   
    
    local r = gg.getResults(11)
    if limit == false then
        r[1].address = r[1].address - 7500
        end
    
    readedMem = rwmem(r[1].address, 50000)
    save(readedMem)
    gg.clearResults()
    end
    
-----------------------------------------------------------------------------------------------------
-- 𝐑𝐞𝐬𝐩𝐞𝐜𝐭 𝐂𝐫𝐞𝐚𝐭𝐨𝐫𝐬. 𝐃𝐨𝐧'𝐭 𝐑𝐞𝐦𝐨𝐯𝐞 𝐂𝐫𝐞𝐝𝐢𝐭 𝐌𝐨𝐝𝐮𝐥𝐞𝐬..!!
-- 𝐂𝐨𝐝𝐞𝐝 𝐁𝐲 : 𝐄𝐒𝐓𝐄𝐁𝐀𝐍_𝐙𝐗𝐗
-----------------------------------------------------------------------------------------------------

function TlsTunnel()
local utf8 = {}
local bit = {
  data32 = {}
}
do
  do
    for SRD1_5_ = 1, 32 do
      bit.data32[SRD1_5_] = 2 ^ (32 - SRD1_5_)
    end
  end
end
local toby = string.byte
function utf8.charbytes(s, i)
  i = i or 1
  local c = string.byte(s, i)
  if c > 0 and c <= 127 then
    do return 1 end
    return
  end
  if c >= 194 and c <= 223 then
    do return 2 end
    return
  end
  if c >= 224 and c <= 239 then
    do return 3 end
    return
  end
  if c >= 240 and c <= 244 then
    return 4
  end
  return 1
end

local ded
function bit:d2b(arg)
  if arg == nil then
    return
  end
  local tr, c = {}, arg < 0
  if c then
    arg = 0 - arg
  end
  do
    do
      for SRD1_7_ = 1, 32 do
        if arg >= self.data32[SRD1_7_] then
          tr[SRD1_7_] = 1
          arg = arg - self.data32[SRD1_7_]
        else
          tr[SRD1_7_] = 0
        end
      end
    end
  end
  if c then
    tr = self:_bnot(tr)
    tr = self:b2d(tr) + 1
    tr = self:d2b(tr)
  end
  return tr
end

function bit:b2d(arg, neg)
  local nr = 0
  if arg[1] == 1 and neg == true then
    arg = self:_bnot(arg)
    nr = self:b2d(arg) + 1
    nr = 0 - nr
  else
    do
      for SRD1_7_ = 1, 32 do
        if arg[SRD1_7_] == 1 then
          nr = nr + 2 ^ (32 - SRD1_7_)
        end
      end
    end
  end
  return nr
end

function bit:_and(a, b)
  local op1 = self:d2b(a)
  local op2 = self:d2b(b)
  local r = {}
  do
    do
      for SRD1_9_ = 1, 32 do
        if op1[SRD1_9_] == 1 and op2[SRD1_9_] == 1 then
          r[SRD1_9_] = 1
        else
          r[SRD1_9_] = 0
        end
      end
    end
  end
  return self:b2d(r, true)
end

function bit:_or(a, b)
  local op1 = self:d2b(a)
  local op2 = self:d2b(b)
  local r = {}
  do
    do
      for SRD1_9_ = 1, 32 do
        if op1[SRD1_9_] == 1 or op2[SRD1_9_] == 1 then
          r[SRD1_9_] = 1
        else
          r[SRD1_9_] = 0
        end
      end
    end
  end
  return self:b2d(r, true)
end

function bit:_xor(a, b)
  local op1 = self:d2b(a)
  if op1 == nil then
    return nil
  end
  local op2 = self:d2b(b)
  if op2 == nil then
    return nil
  end
  local r = {}
  do
    do
      for SRD1_9_ = 1, 32 do
        if op1[SRD1_9_] == op2[SRD1_9_] then
          r[SRD1_9_] = 0
        else
          r[SRD1_9_] = 1
        end
      end
    end
  end
  return self:b2d(r, true)
end

local switch = {
  [1] = function(s, pos)
    local c1 = toby(s, pos)
    return c1
  end
  ,
  [2] = function(s, pos)
    local c1 = toby(s, pos)
    local c2 = toby(s, pos + 1)
    local int1 = bit:_and(31, c1)
    local int2 = bit:_and(63, c2)
    return bit:_or(bit:_lshift(int1, 6), int2)
  end
  ,
  [3] = function(s, pos)
    local c1 = toby(s, pos)
    local c2 = toby(s, pos + 1)
    local c3 = toby(s, pos + 2)
    local int1 = bit:_and(15, c1)
    local int2 = bit:_and(63, c2)
    local int3 = bit:_and(63, c3)
    local o2 = bit:_or(bit:_lshift(int1, 12), bit:_lshift(int2, 6))
    local dt = bit:_or(o2, int3)
    return dt
  end
  ,
  [4] = function(s, pos)
    local c1 = toby(s, pos)
    local c2 = toby(s, pos + 1)
    local c3 = toby(s, pos + 2)
    local c4 = toby(s, pos + 3)
    local int1 = bit:_and(15, c1)
    local int2 = bit:_and(63, c2)
    local int3 = bit:_and(63, c3)
    local int4 = bit:_and(63, c4)
    local o2 = bit:_or(bit:_lshift(int1, 18), bit:_lshift(int2, 12))
    local o3 = bit:_or(o2, bit:_lshift(int3, 6))
    local o4 = bit:_or(o3, int4)
    return o4
  end
  
}
function bit:_bnot(op1)
  local r = {}
  do
    do
      for SRD1_6_ = 1, 32 do
        if op1[SRD1_6_] == 1 then
          r[SRD1_6_] = 0
        else
          r[SRD1_6_] = 1
        end
      end
    end
  end
  return r
end

function bit:_not(a)
  local op1 = self:d2b(a)
  local r = self:_bnot(op1)
  return self:b2d(r, true)
end

function bit:charCodeAt(s)
  local pos, int, H, L = 1, 0, 0, 0
  local slen = string.len(s)
  local allByte = {}
  while pos <= slen do
    local tLen = utf8.charbytes(s, pos)
    if tLen >= 1 and tLen <= 4 then
      if tLen == 4 then
        int = switch[4](s, pos)
        H = math.floor((int - 65536) / 1024) + 55296
        L = (int - 65536) % 1024 + 56320
        table.insert(allByte, H)
        table.insert(allByte, L)
      else
        int = switch[tLen](s, pos)
        table.insert(allByte, int)
      end
    end
    pos = pos + tLen
  end
  return allByte
end

function bit:_rshift(a, n)
  local r = 0
  if a < 0 then
    r = 0 - self:_frshift(0 - a, n)
  elseif a >= 0 then
    r = self:_frshift(a, n)
  end
  return r
end

function bit:_frshift(a, n)
  local op1 = self:d2b(a)
  local r = self:d2b(0)
  local left = 32 - n
  if n < 32 and n > 0 then
    do
      for SRD1_9_ = left, 1, -1 do
        r[SRD1_9_ + n] = op1[SRD1_9_]
      end
    end
  end
  return self:b2d(r)
end

function bit:_lshift(a, n)
  local op1 = self:d2b(a)
  local r = self:d2b(0)
  if n < 32 and n > 0 then
    do
      for SRD1_8_ = n, 31 do
        r[SRD1_8_ - n + 1] = op1[SRD1_8_ + 1]
      end
    end
  end
  return self:b2d(r, true)
end

function trim(s)
  return s:match("^%s*(.*)"):match("(.-)%s*$")
end

local json = {}
local kind_of = function(obj)
  if type(obj) ~= "table" then
    return type(obj)
  end
  local i = 1
  do
    do
      for SRD1_5_ in pairs(obj) do
        if obj[i] ~= nil then
          i = i + 1
        else
          return "table"
        end
      end
    end
  end
  if i == 1 then
    do return "table" end
    return
  end
  return "array"
end

local escape_str = function(s)
  local in_char = {
    "\\",
    "\"",
    "/",
    "\b",
    "\f",
    "\n",
    "\r",
    "\t"
  }
  local out_char = {
    "\\",
    "\"",
    "/",
    "b",
    "f",
    "n",
    "r",
    "t"
  }
  do
    do
      for SRD1_6_, SRD1_7_ in ipairs(in_char) do
        s = s:gsub(SRD1_7_, "\\" .. out_char[SRD1_6_])
      end
    end
  end
  return s
end

local skip_delim = function(str, pos, delim, err_if_missing)
  pos = pos + #str:match("^%s*", pos)
  if str:sub(pos, pos) ~= delim then
    if err_if_missing then
      error("Expected " .. delim .. " near position " .. pos)
    end
    return pos, false
  end
  return pos + 1, true
end

local function parse_str_val(str, pos, val)
  val = val or ""
  local early_end_error = "End of input found while parsing string."
  if pos > #str then
    error(early_end_error)
  end
  local c = str:sub(pos, pos)
  if c == "\"" then
    return val, pos + 1
  end
  if c ~= "\\" then
    return parse_str_val(str, pos + 1, val .. c)
  end
  local esc_map = {
    b = "\b",
    f = "\f",
    n = "\n",
    r = "\r",
    t = "\t"
  }
  local nextc = str:sub(pos + 1, pos + 1)
  if not nextc then
    error(early_end_error)
  end
  return parse_str_val(str, pos + 2, val .. (esc_map[nextc] or nextc))
end

local parse_num_val = function(str, pos)
  local num_str = str:match("^-?%d+%.?%d*[eE]?[+-]?%d*", pos)
  local val = tonumber(num_str)
  if not val then
    error("Error parsing number at position " .. pos .. ".")
  end
  return val, pos + #num_str
end

function json.stringify(obj, as_key)
  local s = {}
  local kind = kind_of(obj)
  if kind == "array" then
    if as_key then
      error("Can't encode array as key.")
    end
    s[#s + 1] = "["
    do
      do
        for SRD1_7_, SRD1_8_ in ipairs(obj) do
          if SRD1_7_ > 1 then
            s[#s + 1] = ", "
          end
          s[#s + 1] = json.stringify(SRD1_8_)
        end
      end
    end
    s[#s + 1] = "]"
  elseif kind == "table" then
    if as_key then
      error("Can't encode table as key.")
    end
    s[#s + 1] = "{"
    do
      do
        for SRD1_7_, SRD1_8_ in pairs(obj) do
          if #s > 1 then
            s[#s + 1] = ", "
          end
          s[#s + 1] = json.stringify(SRD1_7_, true)
          s[#s + 1] = ":"
          s[#s + 1] = json.stringify(SRD1_8_)
        end
      end
    end
    s[#s + 1] = "}"
  else
    if kind == "string" then
      do return "\"" .. escape_str(obj) .. "\"" end
      return
    end
    if kind == "number" then
      if as_key then
        return "\"" .. tostring(obj) .. "\""
      end
      do return tostring(obj) end
      return
    end
    if kind == "boolean" then
      do return tostring(obj) end
      return
    end
    if kind == "nil" then
      do return "null" end
      return
    end
    error("Unjsonifiable type: " .. kind .. ".")
  end
  return table.concat(s)
end

json.null = {}
function json.parse(str, pos, end_delim)
  pos = pos or 1
  if pos > #str then
    error("Reached unexpected end of input.")
  end
  local pos = pos + #str:match("^%s*", pos)
  local first = str:sub(pos, pos)
  if first == "{" then
    do
      local obj, key, delim_found = {}, true, true
      pos = pos + 1
      while true do
        key, pos = json.parse(str, pos, "}")
        if key == nil then
          return obj, pos
        end
        if not delim_found then
          error("Comma missing between object items.")
        end
        pos = skip_delim(str, pos, ":", true)
        obj[key], pos = json.parse(str, pos)
        pos, delim_found = skip_delim(str, pos, ",")
      end
    end
    return
  end
  if first == "[" then
    do
      local arr, val, delim_found = {}, true, true
      pos = pos + 1
      while true do
        val, pos = json.parse(str, pos, "]")
        if val == nil then
          return arr, pos
        end
        if not delim_found then
          error("Comma missing between array items.")
        end
        arr[#arr + 1] = val
        pos, delim_found = skip_delim(str, pos, ",")
      end
    end
    return
  end
  if first == "\"" then
    do return parse_str_val(str, pos + 1) end
    return
  end
  if first == "-" or first:match("%d") then
    do return parse_num_val(str, pos) end
    return
  end
  if first == end_delim then
    do return nil, pos + 1 end
    return
  end
  do
    local literals = {
      ["true"] = true,
      ["false"] = false,
      null = json.null
    }
    do
      do
        for SRD1_9_, SRD1_10_ in pairs(literals) do
          local lit_end = pos + #SRD1_9_ - 1
          if str:sub(pos, lit_end) == SRD1_9_ then
            return SRD1_10_, lit_end + 1
          end
        end
      end
    end
    local pos_info_str = "position " .. pos .. ": " .. str:sub(pos, pos + 10)
    error("Invalid json syntax starting at " .. pos_info_str)
  end
end

function enc(data, b)
  return (data:gsub(".", function(x)
    local r, b = "", x:byte()
    do
      do
        for SRD1_6_ = 8, 1, -1 do
          r = r .. (b % 2 ^ SRD1_6_ - b % 2 ^ (SRD1_6_ - 1) > 0 and "1" or "0")
        end
      end
    end
    return r
  end
  ) .. "0000"):gsub("%d%d%d?%d?%d?%d?", function(x)
    if #x < 6 then
      return ""
    end
    local c = 0
    do
      do
        for SRD1_5_ = 1, 6 do
          c = c + (x:sub(SRD1_5_, SRD1_5_) == "1" and 2 ^ (6 - SRD1_5_) or 0)
        end
      end
    end
    return b:sub(c + 1, c + 1)
  end
  ) .. ({
    "",
    "??",
    "?"
  })[#data % 3 + 1]
end

function dec(data, b)
  data = string.gsub(data, "[^" .. b .. "=]", "")
  return (data:gsub(".", function(x)
    if x == "?" then
      return ""
    end
    local r, f = "", b:find(x) - 1
    do
      do
        for SRD1_6_ = 6, 1, -1 do
          r = r .. (f % 2 ^ SRD1_6_ - f % 2 ^ (SRD1_6_ - 1) > 0 and "1" or "0")
        end
      end
    end
    return r
  end
  ):gsub("%d%d%d?%d?%d?%d?%d?%d?", function(x)
    if #x ~= 8 then
      return ""
    end
    local c = 0
    do
      do
        for SRD1_5_ = 1, 8 do
          c = c + (x:sub(SRD1_5_, SRD1_5_) == "1" and 2 ^ (8 - SRD1_5_) or 0)
        end
      end
    end
    return string.char(c)
  end
  ))
end

function xorDecrypt(key, data)
  local preData, result
  preData = ""
  result = ""
  local bit_key = bit:charCodeAt(key)
  do
    local c = 0
    local c2 = 1
    while c < #data and not (c >= #data) do
      preData = preData .. string.char(tonumber(string.sub(data, c2, c + 2), 16))
      c = c + 2
      c2 = c2 + 2
    end
  end
  local bit_data = bit:charCodeAt(preData)
  do
    local a = 0
    local b = 0
    while a < #preData do
      if b >= #key then
        b = 0
      end
      a = a + 1
      b = b + 1
      local xor = bit:_xor(bit_data[a], bit_key[b])
      if xor ~= nil and xor < 256 then
        result = result .. string.char(bit:_xor(bit_data[a], bit_key[b]))
      end
    end
  end
  return result
end

function rwmem(Address, SizeOrBuffer)
  assert(Address ~= nil, "[rwmem]: error, provided address is nil.")
  _rw = {}
  if type(SizeOrBuffer) == "number" then
    _ = ""
    do
      do
        for SRD1_5_ = 1, SizeOrBuffer do
          _rw[SRD1_5_] = {
            address = Address - 1 + SRD1_5_,
            flags = gg.TYPE_BYTE
          }
        end
      end
    end
    do
      do
        for SRD1_5_, SRD1_6_ in ipairs(gg.getValues(_rw)) do
          if SRD1_6_.value == 0 and limit == true then
            return _
          end
          _ = _ .. string.format("%02X", SRD1_6_.value & 255)
        end
      end
    end
    return _
  end
  Byte = {}
  SizeOrBuffer:gsub("..", function(x)
    Byte[#Byte + 1] = x
    _rw[#Byte] = {
      address = Address - 1 + #Byte,
      flags = gg.TYPE_BYTE,
      value = x .. "h"
    }
  end
  )
  gg.setValues(_rw)
end

function hexdecode(hex)
  return (hex:gsub("%x%x", function(digits)
    return string.char(tonumber(digits, 16))
  end
  ))
end

function hexencode(str)
  return (str:gsub(".", function(char)
    return string.format("%2x", char:byte())
  end
  ))
end

function Dec2Hex(nValue)
  nHexVal = string.format("%X", nValue)
  sHexVal = nHexVal .. ""
  return sHexVal
end

function ToInteger(number)
  return math.floor(tonumber(number) or error("Could not cast '" .. tostring(number) .. "' to number.'"))
end

function save(data)
  io.open(gg.EXT_STORAGE .. "/decrypt.txt", "w"):write(data)
  gg.toast("╔══╗─────────╔╗\n╚╗╗╠═╦═╦╦╦╦╦═╣╚╗\n╔╩╝║╩╣═╣╔╣║║╬║╔╣\n╚══╩═╩═╩╝╠╗║╔╩═╝\n─────────╚═╩╝\n╔══╗───────╔═╦═╗\n║══╬╦╦═╦═╦═╣═╣═╬╦╦╗╔╗\n╠══║║║═╣═╣╩╬═║╔╣║║╚╣╚╗\n╚══╩═╩═╩═╩═╩═╩╝╚═╩═╩═╝")
end

function saveEhi(data)
  io.open(gg.EXT_STORAGE .. "/ehi.txt", "w"):write(data)
end

local ehi
local Http = {}
function Http:New(data)
  ehi = data
end


local includes = function(tab, val)
  do
    do
      for SRD1_5_, SRD1_6_ in ipairs(tab) do
        if SRD1_6_ == val then
          return true
        end
      end
    end
  end
  return false
end


function parseTlsTunnel(data)
  local jsonData = json.parse(hexdecode(data))
  Http:New(jsonData)
      message = ""
      message = message .. "𝐄𝐒𝐓𝐄𝐁𝐀𝐍𝐙𝐗𝐗 𝐃𝐄𝐂𝐑𝐘𝐏𝐓𝐎𝐑\n"
      message = message .. "═════════════════════════\n"
      message = message .. "[*] ServerTLS : " .. ehi.h .. "\n" 
      message = message .. "[*] PortTLS : "  .. ehi.i .. "\n"
      message = message .. "[*] HostSSH : "  .. ehi.y .. "\n"
      message = message .. "[*] PortSSH : "  .. ehi.k .. "\n"
      message = message .. "[*] Username : " .. ehi.f .. "\n"
      message = message .. "[*] Password : " .. ehi.g .. "\n"
      message = message .. "[*] Payload : " .. ehi.n .. "\n"
      message = message .. "[*] PayloadAfterTLS : " .. ehi.r .. "\n"
      message = message .. "[*] Proxy : " .. ehi.t .. "\n"
      message = message .. "[*] ProxyPort : " .. ehi.u .. "\n"
      message = message .. "[*] DomainDNS : " .. ehi.w .. "\n"
      message = message .. "[*] PortDNS : " .. ehi.x .. "\n"
      message = message .. "[*] PublicKey : " .. ehi.z .. "\n"
      message = message .. "[*] ToolsBy : @EstebanZxx\n" 
    gg.copyText(message, true)
    gg.alert(message)
    saveEhi(message)
end

-----------------------------------------------------------------------------------------------------
-- 𝐑𝐞𝐬𝐩𝐞𝐜𝐭 𝐂𝐫𝐞𝐚𝐭𝐨𝐫𝐬. 𝐃𝐨𝐧'𝐭 𝐑𝐞𝐦𝐨𝐯𝐞 𝐂𝐫𝐞𝐝𝐢𝐭 𝐌𝐨𝐝𝐮𝐥𝐞𝐬..!!
-- 𝐂𝐨𝐝𝐞𝐝 𝐁𝐲 : 𝐄𝐒𝐓𝐄𝐁𝐀𝐍_𝐙𝐗𝐗
-----------------------------------------------------------------------------------------------------

  limit = true
  gg.clearResults()
  gg.setVisible(false)
  gg.setRanges(gg.REGION_JAVA_HEAP)
  gg.setVisible(false)
  gg.processResume()
  gg.searchNumber("h 7b 22 41 22 3a", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1)
  if #r < 1 then
    gg.toast("⚠ Metode 1 Gagal")
    hi_method2 = true
  end
  if hi_method2 then
    gg.searchNumber("h 7B 22 63 6F 6E 66 69 67 49 64 65 6E 74 69 66 69 65 72 22 3A", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      return (Menu)
    end
  end
  gg.searchNumber("h7B", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1000)
  readedMem = rwmem(r[1].address, 50000)
  save(hexdecode(readedMem))
  do
    do
      for SRD1_5_, SRD1_6_ in ipairs(r) do
        r[SRD1_5_].flags = gg.TYPE_FLOAT
        r[SRD1_5_].value = "1000"
      end
    end
  end
  gg.setValues(r)
  gg.clearResults()
  parseTlsTunnel(readedMem)
end
-----------------------------------------------------------------------------------------------------
-- 𝐑𝐞𝐬𝐩𝐞𝐜𝐭 𝐂𝐫𝐞𝐚𝐭𝐨𝐫𝐬. 𝐃𝐨𝐧'𝐭 𝐑𝐞𝐦𝐨𝐯𝐞 𝐂𝐫𝐞𝐝𝐢𝐭 𝐌𝐨𝐝𝐮𝐥𝐞𝐬..!!
-- 𝐂𝐨𝐝𝐞𝐝 𝐁𝐲 : 𝐄𝐒𝐓𝐄𝐁𝐀𝐍_𝐙𝐗𝐗
-----------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------
-- 𝐑𝐞𝐬𝐩𝐞𝐜𝐭 𝐂𝐫𝐞𝐚𝐭𝐨𝐫𝐬. 𝐃𝐨𝐧'𝐭 𝐑𝐞𝐦𝐨𝐯𝐞 𝐂𝐫𝐞𝐝𝐢𝐭 𝐌𝐨𝐝𝐮𝐥𝐞𝐬..!!
-- 𝐂𝐨𝐝𝐞𝐝 𝐁𝐲 : 𝐄𝐒𝐓𝐄𝐁𝐀𝐍_𝐙𝐗𝐗
-----------------------------------------------------------------------------------------------------

function NapsternetV()
local utf8 = {}
local bit = {
  data32 = {}
}
do
  do
    for SRD1_5_ = 1, 32 do
      bit.data32[SRD1_5_] = 2 ^ (32 - SRD1_5_)
    end
  end
end
local toby = string.byte
function utf8.charbytes(s, i)
  i = i or 1
  local c = string.byte(s, i)
  if c > 0 and c <= 127 then
    do return 1 end
    return
  end
  if c >= 194 and c <= 223 then
    do return 2 end
    return
  end
  if c >= 224 and c <= 239 then
    do return 3 end
    return
  end
  if c >= 240 and c <= 244 then
    return 4
  end
  return 1
end

local ded
function bit:d2b(arg)
  if arg == nil then
    return
  end
  local tr, c = {}, arg < 0
  if c then
    arg = 0 - arg
  end
  do
    do
      for SRD1_7_ = 1, 32 do
        if arg >= self.data32[SRD1_7_] then
          tr[SRD1_7_] = 1
          arg = arg - self.data32[SRD1_7_]
        else
          tr[SRD1_7_] = 0
        end
      end
    end
  end
  if c then
    tr = self:_bnot(tr)
    tr = self:b2d(tr) + 1
    tr = self:d2b(tr)
  end
  return tr
end

function bit:b2d(arg, neg)
  local nr = 0
  if arg[1] == 1 and neg == true then
    arg = self:_bnot(arg)
    nr = self:b2d(arg) + 1
    nr = 0 - nr
  else
    do
      for SRD1_7_ = 1, 32 do
        if arg[SRD1_7_] == 1 then
          nr = nr + 2 ^ (32 - SRD1_7_)
        end
      end
    end
  end
  return nr
end

function bit:_and(a, b)
  local op1 = self:d2b(a)
  local op2 = self:d2b(b)
  local r = {}
  do
    do
      for SRD1_9_ = 1, 32 do
        if op1[SRD1_9_] == 1 and op2[SRD1_9_] == 1 then
          r[SRD1_9_] = 1
        else
          r[SRD1_9_] = 0
        end
      end
    end
  end
  return self:b2d(r, true)
end

function bit:_or(a, b)
  local op1 = self:d2b(a)
  local op2 = self:d2b(b)
  local r = {}
  do
    do
      for SRD1_9_ = 1, 32 do
        if op1[SRD1_9_] == 1 or op2[SRD1_9_] == 1 then
          r[SRD1_9_] = 1
        else
          r[SRD1_9_] = 0
        end
      end
    end
  end
  return self:b2d(r, true)
end

function bit:_xor(a, b)
  local op1 = self:d2b(a)
  if op1 == nil then
    return nil
  end
  local op2 = self:d2b(b)
  if op2 == nil then
    return nil
  end
  local r = {}
  do
    do
      for SRD1_9_ = 1, 32 do
        if op1[SRD1_9_] == op2[SRD1_9_] then
          r[SRD1_9_] = 0
        else
          r[SRD1_9_] = 1
        end
      end
    end
  end
  return self:b2d(r, true)
end

local switch = {
  [1] = function(s, pos)
    local c1 = toby(s, pos)
    return c1
  end
  ,
  [2] = function(s, pos)
    local c1 = toby(s, pos)
    local c2 = toby(s, pos + 1)
    local int1 = bit:_and(31, c1)
    local int2 = bit:_and(63, c2)
    return bit:_or(bit:_lshift(int1, 6), int2)
  end
  ,
  [3] = function(s, pos)
    local c1 = toby(s, pos)
    local c2 = toby(s, pos + 1)
    local c3 = toby(s, pos + 2)
    local int1 = bit:_and(15, c1)
    local int2 = bit:_and(63, c2)
    local int3 = bit:_and(63, c3)
    local o2 = bit:_or(bit:_lshift(int1, 12), bit:_lshift(int2, 6))
    local dt = bit:_or(o2, int3)
    return dt
  end
  ,
  [4] = function(s, pos)
    local c1 = toby(s, pos)
    local c2 = toby(s, pos + 1)
    local c3 = toby(s, pos + 2)
    local c4 = toby(s, pos + 3)
    local int1 = bit:_and(15, c1)
    local int2 = bit:_and(63, c2)
    local int3 = bit:_and(63, c3)
    local int4 = bit:_and(63, c4)
    local o2 = bit:_or(bit:_lshift(int1, 18), bit:_lshift(int2, 12))
    local o3 = bit:_or(o2, bit:_lshift(int3, 6))
    local o4 = bit:_or(o3, int4)
    return o4
  end
  
}
function bit:_bnot(op1)
  local r = {}
  do
    do
      for SRD1_6_ = 1, 32 do
        if op1[SRD1_6_] == 1 then
          r[SRD1_6_] = 0
        else
          r[SRD1_6_] = 1
        end
      end
    end
  end
  return r
end

function bit:_not(a)
  local op1 = self:d2b(a)
  local r = self:_bnot(op1)
  return self:b2d(r, true)
end

function bit:charCodeAt(s)
  local pos, int, H, L = 1, 0, 0, 0
  local slen = string.len(s)
  local allByte = {}
  while pos <= slen do
    local tLen = utf8.charbytes(s, pos)
    if tLen >= 1 and tLen <= 4 then
      if tLen == 4 then
        int = switch[4](s, pos)
        H = math.floor((int - 65536) / 1024) + 55296
        L = (int - 65536) % 1024 + 56320
        table.insert(allByte, H)
        table.insert(allByte, L)
      else
        int = switch[tLen](s, pos)
        table.insert(allByte, int)
      end
    end
    pos = pos + tLen
  end
  return allByte
end

function bit:_rshift(a, n)
  local r = 0
  if a < 0 then
    r = 0 - self:_frshift(0 - a, n)
  elseif a >= 0 then
    r = self:_frshift(a, n)
  end
  return r
end

function bit:_frshift(a, n)
  local op1 = self:d2b(a)
  local r = self:d2b(0)
  local left = 32 - n
  if n < 32 and n > 0 then
    do
      for SRD1_9_ = left, 1, -1 do
        r[SRD1_9_ + n] = op1[SRD1_9_]
      end
    end
  end
  return self:b2d(r)
end

function bit:_lshift(a, n)
  local op1 = self:d2b(a)
  local r = self:d2b(0)
  if n < 32 and n > 0 then
    do
      for SRD1_8_ = n, 31 do
        r[SRD1_8_ - n + 1] = op1[SRD1_8_ + 1]
      end
    end
  end
  return self:b2d(r, true)
end

function trim(s)
  return s:match("^%s*(.*)"):match("(.-)%s*$")
end

local json = {}
local kind_of = function(obj)
  if type(obj) ~= "table" then
    return type(obj)
  end
  local i = 1
  do
    do
      for SRD1_5_ in pairs(obj) do
        if obj[i] ~= nil then
          i = i + 1
        else
          return "table"
        end
      end
    end
  end
  if i == 1 then
    do return "table" end
    return
  end
  return "array"
end

local escape_str = function(s)
  local in_char = {
    "\\",
    "\"",
    "/",
    "\b",
    "\f",
    "\n",
    "\r",
    "\t"
  }
  local out_char = {
    "\\",
    "\"",
    "/",
    "b",
    "f",
    "n",
    "r",
    "t"
  }
  do
    do
      for SRD1_6_, SRD1_7_ in ipairs(in_char) do
        s = s:gsub(SRD1_7_, "\\" .. out_char[SRD1_6_])
      end
    end
  end
  return s
end

local skip_delim = function(str, pos, delim, err_if_missing)
  pos = pos + #str:match("^%s*", pos)
  if str:sub(pos, pos) ~= delim then
    if err_if_missing then
      error("Expected " .. delim .. " near position " .. pos)
    end
    return pos, false
  end
  return pos + 1, true
end

local function parse_str_val(str, pos, val)
  val = val or ""
  local early_end_error = "End of input found while parsing string."
  if pos > #str then
    error(early_end_error)
  end
  local c = str:sub(pos, pos)
  if c == "\"" then
    return val, pos + 1
  end
  if c ~= "\\" then
    return parse_str_val(str, pos + 1, val .. c)
  end
  local esc_map = {
    b = "\b",
    f = "\f",
    n = "\n",
    r = "\r",
    t = "\t"
  }
  local nextc = str:sub(pos + 1, pos + 1)
  if not nextc then
    error(early_end_error)
  end
  return parse_str_val(str, pos + 2, val .. (esc_map[nextc] or nextc))
end

local parse_num_val = function(str, pos)
  local num_str = str:match("^-?%d+%.?%d*[eE]?[+-]?%d*", pos)
  local val = tonumber(num_str)
  if not val then
    error("Error parsing number at position " .. pos .. ".")
  end
  return val, pos + #num_str
end

function json.stringify(obj, as_key)
  local s = {}
  local kind = kind_of(obj)
  if kind == "array" then
    if as_key then
      error("Can't encode array as key.")
    end
    s[#s + 1] = "["
    do
      do
        for SRD1_7_, SRD1_8_ in ipairs(obj) do
          if SRD1_7_ > 1 then
            s[#s + 1] = ", "
          end
          s[#s + 1] = json.stringify(SRD1_8_)
        end
      end
    end
    s[#s + 1] = "]"
  elseif kind == "table" then
    if as_key then
      error("Can't encode table as key.")
    end
    s[#s + 1] = "{"
    do
      do
        for SRD1_7_, SRD1_8_ in pairs(obj) do
          if #s > 1 then
            s[#s + 1] = ", "
          end
          s[#s + 1] = json.stringify(SRD1_7_, true)
          s[#s + 1] = ":"
          s[#s + 1] = json.stringify(SRD1_8_)
        end
      end
    end
    s[#s + 1] = "}"
  else
    if kind == "string" then
      do return "\"" .. escape_str(obj) .. "\"" end
      return
    end
    if kind == "number" then
      if as_key then
        return "\"" .. tostring(obj) .. "\""
      end
      do return tostring(obj) end
      return
    end
    if kind == "boolean" then
      do return tostring(obj) end
      return
    end
    if kind == "nil" then
      do return "null" end
      return
    end
    error("Unjsonifiable type: " .. kind .. ".")
  end
  return table.concat(s)
end

json.null = {}
function json.parse(str, pos, end_delim)
  pos = pos or 1
  if pos > #str then
    error("Reached unexpected end of input.")
  end
  local pos = pos + #str:match("^%s*", pos)
  local first = str:sub(pos, pos)
  if first == "{" then
    do
      local obj, key, delim_found = {}, true, true
      pos = pos + 1
      while true do
        key, pos = json.parse(str, pos, "}")
        if key == nil then
          return obj, pos
        end
        if not delim_found then
          error("Comma missing between object items.")
        end
        pos = skip_delim(str, pos, ":", true)
        obj[key], pos = json.parse(str, pos)
        pos, delim_found = skip_delim(str, pos, ",")
      end
    end
    return
  end
  if first == "[" then
    do
      local arr, val, delim_found = {}, true, true
      pos = pos + 1
      while true do
        val, pos = json.parse(str, pos, "]")
        if val == nil then
          return arr, pos
        end
        if not delim_found then
          error("Comma missing between array items.")
        end
        arr[#arr + 1] = val
        pos, delim_found = skip_delim(str, pos, ",")
      end
    end
    return
  end
  if first == "\"" then
    do return parse_str_val(str, pos + 1) end
    return
  end
  if first == "-" or first:match("%d") then
    do return parse_num_val(str, pos) end
    return
  end
  if first == end_delim then
    do return nil, pos + 1 end
    return
  end
  do
    local literals = {
      ["true"] = true,
      ["false"] = false,
      null = json.null
    }
    do
      do
        for SRD1_9_, SRD1_10_ in pairs(literals) do
          local lit_end = pos + #SRD1_9_ - 1
          if str:sub(pos, lit_end) == SRD1_9_ then
            return SRD1_10_, lit_end + 1
          end
        end
      end
    end
    local pos_info_str = "position " .. pos .. ": " .. str:sub(pos, pos + 10)
    error("Invalid json syntax starting at " .. pos_info_str)
  end
end

function enc(data, b)
  return (data:gsub(".", function(x)
    local r, b = "", x:byte()
    do
      do
        for SRD1_6_ = 8, 1, -1 do
          r = r .. (b % 2 ^ SRD1_6_ - b % 2 ^ (SRD1_6_ - 1) > 0 and "1" or "0")
        end
      end
    end
    return r
  end
  ) .. "0000"):gsub("%d%d%d?%d?%d?%d?", function(x)
    if #x < 6 then
      return ""
    end
    local c = 0
    do
      do
        for SRD1_5_ = 1, 6 do
          c = c + (x:sub(SRD1_5_, SRD1_5_) == "1" and 2 ^ (6 - SRD1_5_) or 0)
        end
      end
    end
    return b:sub(c + 1, c + 1)
  end
  ) .. ({
    "",
    "??",
    "?"
  })[#data % 3 + 1]
end

function dec(data, b)
  data = string.gsub(data, "[^" .. b .. "=]", "")
  return (data:gsub(".", function(x)
    if x == "?" then
      return ""
    end
    local r, f = "", b:find(x) - 1
    do
      do
        for SRD1_6_ = 6, 1, -1 do
          r = r .. (f % 2 ^ SRD1_6_ - f % 2 ^ (SRD1_6_ - 1) > 0 and "1" or "0")
        end
      end
    end
    return r
  end
  ):gsub("%d%d%d?%d?%d?%d?%d?%d?", function(x)
    if #x ~= 8 then
      return ""
    end
    local c = 0
    do
      do
        for SRD1_5_ = 1, 8 do
          c = c + (x:sub(SRD1_5_, SRD1_5_) == "1" and 2 ^ (8 - SRD1_5_) or 0)
        end
      end
    end
    return string.char(c)
  end
  ))
end

function xorDecrypt(key, data)
  local preData, result
  preData = ""
  result = ""
  local bit_key = bit:charCodeAt(key)
  do
    local c = 0
    local c2 = 1
    while c < #data and not (c >= #data) do
      preData = preData .. string.char(tonumber(string.sub(data, c2, c + 2), 16))
      c = c + 2
      c2 = c2 + 2
    end
  end
  local bit_data = bit:charCodeAt(preData)
  do
    local a = 0
    local b = 0
    while a < #preData do
      if b >= #key then
        b = 0
      end
      a = a + 1
      b = b + 1
      local xor = bit:_xor(bit_data[a], bit_key[b])
      if xor ~= nil and xor < 256 then
        result = result .. string.char(bit:_xor(bit_data[a], bit_key[b]))
      end
    end
  end
  return result
end

function rwmem(Address, SizeOrBuffer)
  assert(Address ~= nil, "[rwmem]: error, provided address is nil.")
  _rw = {}
  if type(SizeOrBuffer) == "number" then
    _ = ""
    do
      do
        for SRD1_5_ = 1, SizeOrBuffer do
          _rw[SRD1_5_] = {
            address = Address - 1 + SRD1_5_,
            flags = gg.TYPE_BYTE
          }
        end
      end
    end
    do
      do
        for SRD1_5_, SRD1_6_ in ipairs(gg.getValues(_rw)) do
          if SRD1_6_.value == 0 and limit == true then
            return _
          end
          _ = _ .. string.format("%02X", SRD1_6_.value & 255)
        end
      end
    end
    return _
  end
  Byte = {}
  SizeOrBuffer:gsub("..", function(x)
    Byte[#Byte + 1] = x
    _rw[#Byte] = {
      address = Address - 1 + #Byte,
      flags = gg.TYPE_BYTE,
      value = x .. "h"
    }
  end
  )
  gg.setValues(_rw)
end

function hexdecode(hex)
  return (hex:gsub("%x%x", function(digits)
    return string.char(tonumber(digits, 16))
  end
  ))
end

function hexencode(str)
  return (str:gsub(".", function(char)
    return string.format("%2x", char:byte())
  end
  ))
end

function Dec2Hex(nValue)
  nHexVal = string.format("%X", nValue)
  sHexVal = nHexVal .. ""
  return sHexVal
end

function ToInteger(number)
  return math.floor(tonumber(number) or error("Could not cast '" .. tostring(number) .. "' to number.'"))
end

function save(data)
  io.open(gg.EXT_STORAGE .. "/decrypt.txt", "w"):write(data)
  gg.toast("╔══╗─────────╔╗\n╚╗╗╠═╦═╦╦╦╦╦═╣╚╗\n╔╩╝║╩╣═╣╔╣║║╬║╔╣\n╚══╩═╩═╩╝╠╗║╔╩═╝\n─────────╚═╩╝\n╔══╗───────╔═╦═╗\n║══╬╦╦═╦═╦═╣═╣═╬╦╦╗╔╗\n╠══║║║═╣═╣╩╬═║╔╣║║╚╣╚╗\n╚══╩═╩═╩═╩═╩═╩╝╚═╩═╩═╝")
end

function saveEhi(data)
  io.open(gg.EXT_STORAGE .. "/Zxx_NPV4.txt", "w"):write(data)
end

local ehi
local Http = {}
function Http:New(data)
  ehi = data
end


local includes = function(tab, val)
  do
    do
      for SRD1_5_, SRD1_6_ in ipairs(tab) do
        if SRD1_6_ == val then
          return true
        end
      end
    end
  end
  return false
end

-----------------------------------------------------------------------------------------------------
-- 𝐑𝐞𝐬𝐩𝐞𝐜𝐭 𝐂𝐫𝐞𝐚𝐭𝐨𝐫𝐬. 𝐃𝐨𝐧'𝐭 𝐑𝐞𝐦𝐨𝐯𝐞 𝐂𝐫𝐞𝐝𝐢𝐭 𝐌𝐨𝐝𝐮𝐥𝐞𝐬..!!
-- 𝐂𝐨𝐝𝐞𝐝 𝐁𝐲 : 𝐄𝐒𝐓𝐄𝐁𝐀𝐍_𝐙𝐗𝐗
-----------------------------------------------------------------------------------------------------

  limit = true
  gg.clearResults()
  gg.setVisible(false)
  gg.setRanges(gg.REGION_JAVA_HEAP)
  gg.setVisible(false)
  gg.processResume()
  gg.searchNumber("h 7b 22 76 65 72 73 69 6f 6e 69 6e 67", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1)
  if #r < 1 then
    gg.toast("⚠ Metode 1 Gagal")
    hi_method2 = true
  end
  if hi_method2 then
    gg.searchNumber("h 7B 22 63 6F 6E 66 69 67 49 64 65 6E 74 69 66 69 65 72 22 3A", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      return (Menu)
    end
  end
  gg.searchNumber("h7B", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1000)
  readedMem = rwmem(r[1].address, 50000)
  save(hexdecode(readedMem))
  do
    do
      for SRD1_5_, SRD1_6_ in ipairs(r) do
        r[SRD1_5_].flags = gg.TYPE_FLOAT
        r[SRD1_5_].value = "1000"
      end
    end
  end
  gg.setValues(r)
  gg.clearResults()
end
-----------------------------------------------------------------------------------------------------
-- 𝐑𝐞𝐬𝐩𝐞𝐜𝐭 𝐂𝐫𝐞𝐚𝐭𝐨𝐫𝐬. 𝐃𝐨𝐧'𝐭 𝐑𝐞𝐦𝐨𝐯𝐞 𝐂𝐫𝐞𝐝𝐢𝐭 𝐌𝐨𝐝𝐮𝐥𝐞𝐬..!!
-- 𝐂𝐨𝐝𝐞𝐝 𝐁𝐲 : 𝐄𝐒𝐓𝐄𝐁𝐀𝐍_𝐙𝐗𝐗
-----------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------
-- 𝐑𝐞𝐬𝐩𝐞𝐜𝐭 𝐂𝐫𝐞𝐚𝐭𝐨𝐫𝐬. 𝐃𝐨𝐧'𝐭 𝐑𝐞𝐦𝐨𝐯𝐞 𝐂𝐫𝐞𝐝𝐢𝐭 𝐌𝐨𝐝𝐮𝐥𝐞𝐬..!!
-- 𝐂𝐨𝐝𝐞𝐝 𝐁𝐲 : 𝐄𝐒𝐓𝐄𝐁𝐀𝐍_𝐙𝐗𝐗
-----------------------------------------------------------------------------------------------------

function ResultNapsternetV()
local open = io.open
local function read_file(path)
    local file = open(path, "rb")
    if not file then return nil end
    local content = file:read "*a"
    file:close()
    return content
end
local fileContent = read_file("/sdcard/decrypt.txt");
--gg.alert("𝐄𝐒𝐓𝐄𝐁𝐀𝐍𝐙𝐗𝐗 𝐃𝐄𝐂𝐑𝐘𝐏𝐓𝐎𝐑\n════════════════════\n[*] DataConfig : " .. fileContent .. "\n[*] ToolsBy : @EstebanZxx");
--gg.copyText("𝐄𝐒𝐓𝐄𝐁𝐀𝐍𝐙𝐗𝐗 𝐃𝐄𝐂𝐑𝐘𝐏𝐓𝐎𝐑\n════════════════════\n[*] DataConfig : " .. fileContent .. "\n[*] ToolsBy : @EstebanZxx", true)
print("𝐄𝐒𝐓𝐄𝐁𝐀𝐍𝐙𝐗𝐗 𝐃𝐄𝐂𝐑𝐘𝐏𝐓𝐎𝐑\n════════════════════\n[*] DataConfig : " .. fileContent .. "\n[*] ToolsBy : @EstebanZxx");
gg.skipRestoreState()
gg.setVisible(true)
os.exit()
end

-----------------------------------------------------------------------------------------------------
-- 𝐑𝐞𝐬𝐩𝐞𝐜𝐭 𝐂𝐫𝐞𝐚𝐭𝐨𝐫𝐬. 𝐃𝐨𝐧'𝐭 𝐑𝐞𝐦𝐨𝐯𝐞 𝐂𝐫𝐞𝐝𝐢𝐭 𝐌𝐨𝐝𝐮𝐥𝐞𝐬..!!
-- 𝐂𝐨𝐝𝐞𝐝 𝐁𝐲 : 𝐄𝐒𝐓𝐄𝐁𝐀𝐍_𝐙𝐗𝐗
-----------------------------------------------------------------------------------------------------

function DarkTunnel()
function save(data)
    io.open(gg.EXT_STORAGE .. "/decrypt.txt", "w"):write(hexdecode(data))
    gg.toast("✓ 𝐃𝐞𝐜𝐫𝐲𝐩𝐭 𝐒𝐮𝐜𝐜𝐞𝐬𝐬𝐟𝐮𝐥")
    gg.alert("╔══╗─────────╔╗\n╚╗╗╠═╦═╦╦╦╦╦═╣╚╗\n╔╩╝║╩╣═╣╔╣║║╬║╔╣\n╚══╩═╩═╩╝╠╗║╔╩═╝\n─────────╚═╩╝\n╔══╗───────╔═╦═╗\n║══╬╦╦═╦═╦═╣═╣═╬╦╦╗╔╗\n╠══║║║═╣═╣╩╬═║╔╣║║╚╣╚╗\n╚══╩═╩═╩═╩═╩═╩╝╚═╩═╩═╝", "𝘽𝙖𝙘𝙠 𝙈𝙚𝙣𝙪")
    end
  gg.clearResults()
  gg.setRanges(gg.REGION_ANONYMOUS)
  gg.setVisible(true)
  gg.searchNumber("h537368436F6E6669674C6F636B6564C3A9537368436F6E666967", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1)
     if #r < 1 then
    gg.toast("✘ 𝐌𝐞𝐭𝐡𝐨𝐝 𝟏 𝐅𝐚𝐢𝐥𝐞𝐝")
    dark_2 = true
    end
    if dark_2 then
    gg.searchNumber("h53 73 68 43 6f 6e 66 69 67 4c 6f 63 6b 65 64 e9 53 73 68 43 6f 6e 66 69 67", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("✘ 𝐌𝐞𝐭𝐡𝐨𝐝 𝟐 𝐅𝐚𝐢𝐥𝐞𝐝")
      dark_3 = true
      end
      end
    if dark_3 then
    gg.searchNumber("h53 73 68 43 6f 6e 66 69 67 4c 6f 63 6b 65 64", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("✘ 𝐌𝐞𝐭𝐡𝐨𝐝 𝟑 𝐅𝐚𝐢𝐥𝐞𝐝")
      dark_4 = true
      end
      end
    if dark_4 then
    gg.toast("✘ 𝐃𝐞𝐜𝐫𝐲𝐩𝐭 𝐅𝐚𝐢𝐥𝐞𝐝")
    return (Menu)
    end
  local r = gg.getResults(1000)
  if limit == false then
    r[1].address = r[1].address - 0x2000
  end
  readedMem = rwmem(r[1].address, 10000)
  save(readedMem)
  gg.clearResults()
end

-----------------------------------------------------------------------------------------------------
-- 𝐑𝐞𝐬𝐩𝐞𝐜𝐭 𝐂𝐫𝐞𝐚𝐭𝐨𝐫𝐬. 𝐃𝐨𝐧'𝐭 𝐑𝐞𝐦𝐨𝐯𝐞 𝐂𝐫𝐞𝐝𝐢𝐭 𝐌𝐨𝐝𝐮𝐥𝐞𝐬..!!
-- 𝐂𝐨𝐝𝐞𝐝 𝐁𝐲 : 𝐄𝐒𝐓𝐄𝐁𝐀𝐍_𝐙𝐗𝐗
-----------------------------------------------------------------------------------------------------

function CreditModules()
  gg.alert("𝙲𝚘𝚙𝚢𝚛𝚒𝚐𝚑𝚝 (𝙲) 𝟸0𝟸𝟹 𝙴𝚜𝚝𝚎𝚋𝚊𝚗𝚃𝙾𝙾𝙻𝚂\n𝚗𝚃𝚑𝚒𝚜 𝚂𝚌𝚛𝚒𝚙𝚝 𝙲𝚛𝚎𝚊𝚝𝚎𝚍 𝙰𝚗𝚍 𝙴𝚍𝚒𝚝𝚎𝚍 𝙱𝚢 𝚑𝚝𝚝𝚙𝚜://𝚝.𝚖𝚎/𝙴𝚜𝚝𝚎𝚋𝚊𝚗𝚉𝚡𝚡 @𝙺𝚖𝚔𝚣𝚣𝚣 @𝚗𝚘𝚝𝚢𝚘𝚞𝚛𝚜_𝟹𝟸𝟷, 𝚃𝚑𝚒𝚜 𝚂𝚌𝚛𝚒𝚙𝚝 𝙸𝚜 𝙴𝚗𝚌𝚛𝚢𝚙𝚝𝚎𝚍 𝙰𝚗𝚍 𝙽𝚘𝚝 𝙵𝚘𝚛 𝚁𝚎-𝙴𝚍𝚒𝚝𝚒𝚗𝚐.\n𝙰𝚜 𝚠𝚎 𝚔𝚗𝚘𝚠, 𝚢𝚘𝚞'𝚛𝚎 𝚘𝚗𝚕𝚢 𝚎𝚍𝚒𝚝𝚒𝚗𝚐 𝚙𝚊𝚛𝚝 𝚘𝚏 𝚝𝚑𝚎 𝚖𝚎𝚜𝚜𝚊𝚐𝚎 𝚝𝚎𝚖𝚙𝚕𝚊𝚝𝚎, 𝚊𝚗𝚍 𝚒𝚝 𝚍𝚘𝚎𝚜𝚗'𝚝 𝚑𝚎𝚕𝚙 𝚝𝚑𝚎 𝚍𝚎𝚟𝚎𝚕𝚘𝚙𝚖𝚎𝚗𝚝 𝚘𝚏 𝚝𝚑𝚒𝚜 𝚜𝚌𝚛𝚒𝚙𝚝 𝚊𝚝 𝚊𝚕𝚕\n𝚃𝚑𝚒𝚜 𝚙𝚛𝚘𝚐𝚛𝚊𝚖 𝚠𝚒𝚕𝚕 𝚌𝚘𝚗𝚝𝚒𝚗𝚞𝚎 𝚝𝚘 𝚛𝚞𝚗 𝚊𝚜 𝚕𝚘𝚗𝚐 𝚊𝚜 𝚝𝚑𝚎 𝚌𝚛𝚎𝚊𝚝𝚘𝚛𝚜 𝚊𝚗𝚍 𝚎𝚍𝚒𝚝𝚘𝚛𝚜 𝚊𝚛𝚎 𝚊𝚕𝚒𝚟𝚎,\n𝚢𝚘𝚞 𝚌𝚊𝚗 𝚖𝚘𝚗𝚒𝚝𝚘𝚛 𝚝𝚑𝚎𝚒𝚛 𝚙𝚛𝚘𝚐𝚛𝚎𝚜𝚜 𝚘𝚗 𝚝𝚑𝚎 𝚃𝚎𝚕𝚎𝚐𝚛𝚊𝚖 𝙲𝚑𝚊𝚗𝚗𝚎𝚕 / 𝙶𝚛𝚘𝚞𝚙 : 𝐊𝐌𝐊𝐙 𝟏𝟎𝟏 𖠙 ᯓ", "𝘽𝙖𝙘𝙠 𝙈𝙚𝙣𝙪")
gg.skipRestoreState()
gg.setVisible(true)
return (Menu)
end

-----------------------------------------------------------------------------------------------------
-- 𝐑𝐞𝐬𝐩𝐞𝐜𝐭 𝐂𝐫𝐞𝐚𝐭𝐨𝐫𝐬. 𝐃𝐨𝐧'𝐭 𝐑𝐞𝐦𝐨𝐯𝐞 𝐂𝐫𝐞𝐝𝐢𝐭 𝐌𝐨𝐝𝐮𝐥𝐞𝐬..!!
-- 𝐂𝐨𝐝𝐞𝐝 𝐁𝐲 : 𝐄𝐒𝐓𝐄𝐁𝐀𝐍_𝐙𝐗𝐗
-----------------------------------------------------------------------------------------------------

function ExitScript()
print(" ")
print("███████╗  ██╗░░██╗  ██╗░░██╗")
print("╚════██║  ╚██╗██╔╝  ╚██╗██╔╝")
print("░░███╔═╝  ░╚███╔╝░  ░╚███╔╝░")
print("██╔══╝░░  ░██╔██╗░  ░██╔██╗░")
print("███████╗  ██╔╝╚██╗  ██╔╝╚██╗")
print("╚══════╝  ╚═╝░░╚═╝  ╚═╝░░╚═╝")
print(" ")
print("                  ██╗░░██╗")
print("                  ╚██╗██╔╝")
print("                  ░╚███╔╝░")
print("                  ░██╔██╗░")
print("                  ██╔╝╚██╗")
print("                  ╚═╝░░╚═╝")
print(" ")
print("██╗░░██╗███╗░░░███╗██╗░░██╗███████╗")
print("██║░██╔╝████╗░████║██║░██╔╝╚════██║")
print("█████═╝░██╔████╔██║█████═╝░░░███╔═╝")
print("██╔═██╗░██║╚██╔╝██║██╔═██╗░██╔══╝░░")
print("██║░╚██╗██║░╚═╝░██║██║░╚██╗███████╗")
print("╚═╝░░╚═╝╚═╝░░░░░╚═╝╚═╝░░╚═╝╚══════╝")
print("-----------------------------------------------------------------------------------------------------")
print("ꜱᴄʀɪᴘᴛ ᴍᴏᴅᴅᴇʀ ʙʏ : 𝐄𝐒𝐓𝐄𝐁𝐀𝐍_𝐙𝐗𝐗 - 𝐊𝐌𝐊𝐙 𝟏𝟎𝟏 𖠙 ᯓ")
print("-----------------------------------------------------------------------------------------------------")
gg.skipRestoreState()
gg.setVisible(true)
os.exit()
end

-----------------------------------------------------------------------------------------------------
-- 𝐑𝐞𝐬𝐩𝐞𝐜𝐭 𝐂𝐫𝐞𝐚𝐭𝐨𝐫𝐬. 𝐃𝐨𝐧'𝐭 𝐑𝐞𝐦𝐨𝐯𝐞 𝐂𝐫𝐞𝐝𝐢𝐭 𝐌𝐨𝐝𝐮𝐥𝐞𝐬..!!
-- 𝐂𝐨𝐝𝐞𝐝 𝐁𝐲 : 𝐄𝐒𝐓𝐄𝐁𝐀𝐍_𝐙𝐗𝐗
-----------------------------------------------------------------------------------------------------

local utf8 = {}
local bit = {
  data32 = {}
}
do
  do
    for SRD1_5_ = 1, 32 do
      bit.data32[SRD1_5_] = 2 ^ (32 - SRD1_5_)
    end
  end
end
local toby = string.byte
function utf8.charbytes(s, i)
  i = i or 1
  local c = string.byte(s, i)
  if c > 0 and c <= 127 then
    do return 1 end
    return
  end
  if c >= 194 and c <= 223 then
    do return 2 end
    return
  end
  if c >= 224 and c <= 239 then
    do return 3 end
    return
  end
  if c >= 240 and c <= 244 then
    return 4
  end
  return 1
end

local ded
function bit:d2b(arg)
  if arg == nil then
    return
  end
  local tr, c = {}, arg < 0
  if c then
    arg = 0 - arg
  end
  do
    do
      for SRD1_7_ = 1, 32 do
        if arg >= self.data32[SRD1_7_] then
          tr[SRD1_7_] = 1
          arg = arg - self.data32[SRD1_7_]
        else
          tr[SRD1_7_] = 0
        end
      end
    end
  end
  if c then
    tr = self:_bnot(tr)
    tr = self:b2d(tr) + 1
    tr = self:d2b(tr)
  end
  return tr
end

function bit:b2d(arg, neg)
  local nr = 0
  if arg[1] == 1 and neg == true then
    arg = self:_bnot(arg)
    nr = self:b2d(arg) + 1
    nr = 0 - nr
  else
    do
      for SRD1_7_ = 1, 32 do
        if arg[SRD1_7_] == 1 then
          nr = nr + 2 ^ (32 - SRD1_7_)
        end
      end
    end
  end
  return nr
end

function bit:_and(a, b)
  local op1 = self:d2b(a)
  local op2 = self:d2b(b)
  local r = {}
  do
    do
      for SRD1_9_ = 1, 32 do
        if op1[SRD1_9_] == 1 and op2[SRD1_9_] == 1 then
          r[SRD1_9_] = 1
        else
          r[SRD1_9_] = 0
        end
      end
    end
  end
  return self:b2d(r, true)
end

function bit:_or(a, b)
  local op1 = self:d2b(a)
  local op2 = self:d2b(b)
  local r = {}
  do
    do
      for SRD1_9_ = 1, 32 do
        if op1[SRD1_9_] == 1 or op2[SRD1_9_] == 1 then
          r[SRD1_9_] = 1
        else
          r[SRD1_9_] = 0
        end
      end
    end
  end
  return self:b2d(r, true)
end

function bit:_xor(a, b)
  local op1 = self:d2b(a)
  if op1 == nil then
    return nil
  end
  local op2 = self:d2b(b)
  if op2 == nil then
    return nil
  end
  local r = {}
  do
    do
      for SRD1_9_ = 1, 32 do
        if op1[SRD1_9_] == op2[SRD1_9_] then
          r[SRD1_9_] = 0
        else
          r[SRD1_9_] = 1
        end
      end
    end
  end
  return self:b2d(r, true)
end

local switch = {
  [1] = function(s, pos)
    local c1 = toby(s, pos)
    return c1
  end
  ,
  [2] = function(s, pos)
    local c1 = toby(s, pos)
    local c2 = toby(s, pos + 1)
    local int1 = bit:_and(31, c1)
    local int2 = bit:_and(63, c2)
    return bit:_or(bit:_lshift(int1, 6), int2)
  end
  ,
  [3] = function(s, pos)
    local c1 = toby(s, pos)
    local c2 = toby(s, pos + 1)
    local c3 = toby(s, pos + 2)
    local int1 = bit:_and(15, c1)
    local int2 = bit:_and(63, c2)
    local int3 = bit:_and(63, c3)
    local o2 = bit:_or(bit:_lshift(int1, 12), bit:_lshift(int2, 6))
    local dt = bit:_or(o2, int3)
    return dt
  end
  ,
  [4] = function(s, pos)
    local c1 = toby(s, pos)
    local c2 = toby(s, pos + 1)
    local c3 = toby(s, pos + 2)
    local c4 = toby(s, pos + 3)
    local int1 = bit:_and(15, c1)
    local int2 = bit:_and(63, c2)
    local int3 = bit:_and(63, c3)
    local int4 = bit:_and(63, c4)
    local o2 = bit:_or(bit:_lshift(int1, 18), bit:_lshift(int2, 12))
    local o3 = bit:_or(o2, bit:_lshift(int3, 6))
    local o4 = bit:_or(o3, int4)
    return o4
  end
  
}
function bit:_bnot(op1)
  local r = {}
  do
    do
      for SRD1_6_ = 1, 32 do
        if op1[SRD1_6_] == 1 then
          r[SRD1_6_] = 0
        else
          r[SRD1_6_] = 1
        end
      end
    end
  end
  return r
end

function bit:_not(a)
  local op1 = self:d2b(a)
  local r = self:_bnot(op1)
  return self:b2d(r, true)
end

function bit:charCodeAt(s)
  local pos, int, H, L = 1, 0, 0, 0
  local slen = string.len(s)
  local allByte = {}
  while pos <= slen do
    local tLen = utf8.charbytes(s, pos)
    if tLen >= 1 and tLen <= 4 then
      if tLen == 4 then
        int = switch[4](s, pos)
        H = math.floor((int - 65536) / 1024) + 55296
        L = (int - 65536) % 1024 + 56320
        table.insert(allByte, H)
        table.insert(allByte, L)
      else
        int = switch[tLen](s, pos)
        table.insert(allByte, int)
      end
    end
    pos = pos + tLen
  end
  return allByte
end

function bit:_rshift(a, n)
  local r = 0
  if a < 0 then
    r = 0 - self:_frshift(0 - a, n)
  elseif a >= 0 then
    r = self:_frshift(a, n)
  end
  return r
end

function bit:_frshift(a, n)
  local op1 = self:d2b(a)
  local r = self:d2b(0)
  local left = 32 - n
  if n < 32 and n > 0 then
    do
      for SRD1_9_ = left, 1, -1 do
        r[SRD1_9_ + n] = op1[SRD1_9_]
      end
    end
  end
  return self:b2d(r)
end

function bit:_lshift(a, n)
  local op1 = self:d2b(a)
  local r = self:d2b(0)
  if n < 32 and n > 0 then
    do
      for SRD1_8_ = n, 31 do
        r[SRD1_8_ - n + 1] = op1[SRD1_8_ + 1]
      end
    end
  end
  return self:b2d(r, true)
end

function trim(s)
  return s:match("^%s*(.*)"):match("(.-)%s*$")
end

local json = {}
local kind_of = function(obj)
  if type(obj) ~= "table" then
    return type(obj)
  end
  local i = 1
  do
    do
      for SRD1_5_ in pairs(obj) do
        if obj[i] ~= nil then
          i = i + 1
        else
          return "table"
        end
      end
    end
  end
  if i == 1 then
    do return "table" end
    return
  end
  return "array"
end

local escape_str = function(s)
  local in_char = {
    "\\",
    "\"",
    "/",
    "\b",
    "\f",
    "\n",
    "\r",
    "\t"
  }
  local out_char = {
    "\\",
    "\"",
    "/",
    "b",
    "f",
    "n",
    "r",
    "t"
  }
  do
    do
      for SRD1_6_, SRD1_7_ in ipairs(in_char) do
        s = s:gsub(SRD1_7_, "\\" .. out_char[SRD1_6_])
      end
    end
  end
  return s
end

local skip_delim = function(str, pos, delim, err_if_missing)
  pos = pos + #str:match("^%s*", pos)
  if str:sub(pos, pos) ~= delim then
    if err_if_missing then
      error("Expected " .. delim .. " near position " .. pos)
    end
    return pos, false
  end
  return pos + 1, true
end

local function parse_str_val(str, pos, val)
  val = val or ""
  local early_end_error = "End of input found while parsing string."
  if pos > #str then
    error(early_end_error)
  end
  local c = str:sub(pos, pos)
  if c == "\"" then
    return val, pos + 1
  end
  if c ~= "\\" then
    return parse_str_val(str, pos + 1, val .. c)
  end
  local esc_map = {
    b = "\b",
    f = "\f",
    n = "\n",
    r = "\r",
    t = "\t"
  }
  local nextc = str:sub(pos + 1, pos + 1)
  if not nextc then
    error(early_end_error)
  end
  return parse_str_val(str, pos + 2, val .. (esc_map[nextc] or nextc))
end

local parse_num_val = function(str, pos)
  local num_str = str:match("^-?%d+%.?%d*[eE]?[+-]?%d*", pos)
  local val = tonumber(num_str)
  if not val then
    error("Error parsing number at position " .. pos .. ".")
  end
  return val, pos + #num_str
end

function json.stringify(obj, as_key)
  local s = {}
  local kind = kind_of(obj)
  if kind == "array" then
    if as_key then
      error("Can't encode array as key.")
    end
    s[#s + 1] = "["
    do
      do
        for SRD1_7_, SRD1_8_ in ipairs(obj) do
          if SRD1_7_ > 1 then
            s[#s + 1] = ", "
          end
          s[#s + 1] = json.stringify(SRD1_8_)
        end
      end
    end
    s[#s + 1] = "]"
  elseif kind == "table" then
    if as_key then
      error("Can't encode table as key.")
    end
    s[#s + 1] = "{"
    do
      do
        for SRD1_7_, SRD1_8_ in pairs(obj) do
          if #s > 1 then
            s[#s + 1] = ", "
          end
          s[#s + 1] = json.stringify(SRD1_7_, true)
          s[#s + 1] = ":"
          s[#s + 1] = json.stringify(SRD1_8_)
        end
      end
    end
    s[#s + 1] = "}"
  else
    if kind == "string" then
      do return "\"" .. escape_str(obj) .. "\"" end
      return
    end
    if kind == "number" then
      if as_key then
        return "\"" .. tostring(obj) .. "\""
      end
      do return tostring(obj) end
      return
    end
    if kind == "boolean" then
      do return tostring(obj) end
      return
    end
    if kind == "nil" then
      do return "null" end
      return
    end
    error("Unjsonifiable type: " .. kind .. ".")
  end
  return table.concat(s)
end

json.null = {}
function json.parse(str, pos, end_delim)
  pos = pos or 1
  if pos > #str then
    error("Reached unexpected end of input.")
  end
  local pos = pos + #str:match("^%s*", pos)
  local first = str:sub(pos, pos)
  if first == "{" then
    do
      local obj, key, delim_found = {}, true, true
      pos = pos + 1
      while true do
        key, pos = json.parse(str, pos, "}")
        if key == nil then
          return obj, pos
        end
        if not delim_found then
          error("Comma missing between object items.")
        end
        pos = skip_delim(str, pos, ":", true)
        obj[key], pos = json.parse(str, pos)
        pos, delim_found = skip_delim(str, pos, ",")
      end
    end
    return
  end
  if first == "[" then
    do
      local arr, val, delim_found = {}, true, true
      pos = pos + 1
      while true do
        val, pos = json.parse(str, pos, "]")
        if val == nil then
          return arr, pos
        end
        if not delim_found then
          error("Comma missing between array items.")
        end
        arr[#arr + 1] = val
        pos, delim_found = skip_delim(str, pos, ",")
      end
    end
    return
  end
  if first == "\"" then
    do return parse_str_val(str, pos + 1) end
    return
  end
  if first == "-" or first:match("%d") then
    do return parse_num_val(str, pos) end
    return
  end
  if first == end_delim then
    do return nil, pos + 1 end
    return
  end
  do
    local literals = {
      ["true"] = true,
      ["false"] = false,
      null = json.null
    }
    do
      do
        for SRD1_9_, SRD1_10_ in pairs(literals) do
          local lit_end = pos + #SRD1_9_ - 1
          if str:sub(pos, lit_end) == SRD1_9_ then
            return SRD1_10_, lit_end + 1
          end
        end
      end
    end
    local pos_info_str = "position " .. pos .. ": " .. str:sub(pos, pos + 10)
    error("Invalid json syntax starting at " .. pos_info_str)
  end
end

function enc(data, b)
  return (data:gsub(".", function(x)
    local r, b = "", x:byte()
    do
      do
        for SRD1_6_ = 8, 1, -1 do
          r = r .. (b % 2 ^ SRD1_6_ - b % 2 ^ (SRD1_6_ - 1) > 0 and "1" or "0")
        end
      end
    end
    return r
  end
  ) .. "0000"):gsub("%d%d%d?%d?%d?%d?", function(x)
    if #x < 6 then
      return ""
    end
    local c = 0
    do
      do
        for SRD1_5_ = 1, 6 do
          c = c + (x:sub(SRD1_5_, SRD1_5_) == "1" and 2 ^ (6 - SRD1_5_) or 0)
        end
      end
    end
    return b:sub(c + 1, c + 1)
  end
  ) .. ({
    "",
    "??",
    "?"
  })[#data % 3 + 1]
end

function dec(data, b)
  data = string.gsub(data, "[^" .. b .. "=]", "")
  return (data:gsub(".", function(x)
    if x == "?" then
      return ""
    end
    local r, f = "", b:find(x) - 1
    do
      do
        for SRD1_6_ = 6, 1, -1 do
          r = r .. (f % 2 ^ SRD1_6_ - f % 2 ^ (SRD1_6_ - 1) > 0 and "1" or "0")
        end
      end
    end
    return r
  end
  ):gsub("%d%d%d?%d?%d?%d?%d?%d?", function(x)
    if #x ~= 8 then
      return ""
    end
    local c = 0
    do
      do
        for SRD1_5_ = 1, 8 do
          c = c + (x:sub(SRD1_5_, SRD1_5_) == "1" and 2 ^ (8 - SRD1_5_) or 0)
        end
      end
    end
    return string.char(c)
  end
  ))
end

function xorDecrypt(key, data)
  local preData, result
  preData = ""
  result = ""
  local bit_key = bit:charCodeAt(key)
  do
    local c = 0
    local c2 = 1
    while c < #data and not (c >= #data) do
      preData = preData .. string.char(tonumber(string.sub(data, c2, c + 2), 16))
      c = c + 2
      c2 = c2 + 2
    end
  end
  local bit_data = bit:charCodeAt(preData)
  do
    local a = 0
    local b = 0
    while a < #preData do
      if b >= #key then
        b = 0
      end
      a = a + 1
      b = b + 1
      local xor = bit:_xor(bit_data[a], bit_key[b])
      if xor ~= nil and xor < 256 then
        result = result .. string.char(bit:_xor(bit_data[a], bit_key[b]))
      end
    end
  end
  return result
end

function decryptEhi(salt, data)
  data = dec(string.reverse(data), "RkLC2QaVMPYgGJW/A4f7qzDb9e+t6Hr0Zp8OlNyjuxKcTw1o5EIimhBn3UvdSFXs?")
  return xorDecrypt(salt, string.sub(data, 1, #data))
end

function decryptEhil(salt, data)
  data = dec(string.reverse(data), "t6uxKcTwhBn3UvRkLC2QaVM1o5A4f7Hr0Zp8OyjqzDb9e+dSFXsEIimPYgGJW/lN?")
  return xorDecrypt(salt, string.sub(data, 1, #data))
end

function rwmem(Address, SizeOrBuffer)
  assert(Address ~= nil, "[rwmem]: error, provided address is nil.")
  _rw = {}
  if type(SizeOrBuffer) == "number" then
    _ = ""
    do
      do
        for SRD1_5_ = 1, SizeOrBuffer do
          _rw[SRD1_5_] = {
            address = Address - 1 + SRD1_5_,
            flags = gg.TYPE_BYTE
          }
        end
      end
    end
    do
      do
        for SRD1_5_, SRD1_6_ in ipairs(gg.getValues(_rw)) do
          if SRD1_6_.value == 0 and limit == true then
            return _
          end
          _ = _ .. string.format("%02X", SRD1_6_.value & 255)
        end
      end
    end
    return _
  end
  Byte = {}
  SizeOrBuffer:gsub("..", function(x)
    Byte[#Byte + 1] = x
    _rw[#Byte] = {
      address = Address - 1 + #Byte,
      flags = gg.TYPE_BYTE,
      value = x .. "h"
    }
  end
  )
  gg.setValues(_rw)
end

function hexdecode(hex)
  return (hex:gsub("%x%x", function(digits)
    return string.char(tonumber(digits, 16))
  end
  ))
end

function hexencode(str)
  return (str:gsub(".", function(char)
    return string.format("%2x", char:byte())
  end
  ))
end

function Dec2Hex(nValue)
  nHexVal = string.format("%X", nValue)
  sHexVal = nHexVal .. ""
  return sHexVal
end

function ToInteger(number)
  return math.floor(tonumber(number) or error("Could not cast '" .. tostring(number) .. "' to number.'"))
end

function save(data)
  io.open(gg.EXT_STORAGE .. "/decrypt.txt", "w"):write(data)
  gg.toast("╔══╗─────────╔╗\n╚╗╗╠═╦═╦╦╦╦╦═╣╚╗\n╔╩╝║╩╣═╣╔╣║║╬║╔╣\n╚══╩═╩═╩╝╠╗║╔╩═╝\n─────────╚═╩╝\n╔══╗───────╔═╦═╗\n║══╬╦╦═╦═╦═╣═╣═╬╦╦╗╔╗\n╠══║║║═╣═╣╩╬═║╔╣║║╚╣╚╗\n╚══╩═╩═╩═╩═╩═╩╝╚═╩═╩═╝")
end

function saveEhi(data)
  io.open(gg.EXT_STORAGE .. "/ehi.txt", "w"):write(data)
end

local ehi, configSalt
local Http = {}
function Http:New(data)
  ehi = data
  if data.configSalt == "" then
    configSalt = "EVZJNI"
  else
    configSalt = data.configSalt
  end
end

function Http:Dec(key)
  if ehi.configVersionCode > 10000 then
    if ehi[key] then
      do return decryptEhil(configSalt, ehi[key]) end
      return
    end
    do return "N/A" end
    return
  end
  if ehi[key] then
    do return decryptEhi(configSalt, ehi[key]) end
    return
  end
  return "N/A"
end

function Http:TunnelType()
  if ehi.tunnelType == "ssl_proxy_payload_ssh" then
    do return "SSH -> TLS/SSL + Proxy -> Custom Payload" end
    return
  end
  if ehi.tunnelType == "http_obfs_shadowsocks" then
    do return "Shadowsocks -> HTTP (Obfs)" end
    return
  end
  if ehi.tunnelType == "ssl_ssh" then
    do return "SSH -> TLS/SSL (stunnel)" end
    return
  end
  if ehi.tunnelType == "proxy_payload_ssh" then
    do return "SSH -> HTTP Proxy -> Custom Payload" end
    return
  end
  if ehi.tunnelType == "proxy_ssh" then
    do return "SSH -> HTTP Proxy" end
    return
  end
  if ehi.tunnelType == "direct_shadowsocks" then
    do return "Direct Shadowsocks" end
    return
  end
  if ehi.tunnelType == "direct_payload_ssh" then
    do return "SSH -> Direct -> Custom Payload" end
    return
  end

  if ehi.tunnelType == "dnstt_ssh" then
    do return "DNS (DNSTT) :  SSH" end
    return
  end 
  return ehi.tunnelType
end

local includes = function(tab, val)
  do
    do
      for SRD1_5_, SRD1_6_ in ipairs(tab) do
        if SRD1_6_ == val then
          return true
        end
      end
    end
  end
  return false
end

local ssh_mode = {
  "ssl_proxy_payload_ssh",
  "direct_payload_ssh",
  "proxy_payload_ssh",
  "proxy_ssh",
  "ssl_ssh"
}
function parseHttpInjector(data)
  local jsonData = json.parse(hexdecode(data))
  Http:New(jsonData)
  if includes(ssh_mode, ehi.tunnelType) then
      message = ""
      
      message = message .. "𝐄𝐒𝐓𝐄𝐁𝐀𝐍𝐙𝐗𝐗 𝐃𝐄𝐂𝐑𝐘𝐏𝐓𝐎𝐑\n"
      message = message .. "════════════════════\n" 
      if ehi.overwriteServerData ~= "" then
      serverData = json.parse(ehi.overwriteServerData)
      message = message .. "[*] ServerEvozi : " .. serverData.name .. " (" .. serverData.ip .. ")\n"
      message = message .. "[*] PortEvozi : " .. serverData.sshPort .. " SSH " .. serverData.sshSslPort .. "\n"
      end
      message = message .. "[*] Hostname : " .. Http:Dec("host") .. "\n" 
      message = message .. "[*] Port : "  .. ehi.port .. "\n"
      message = message .. "[*] Username : "  .. Http:Dec("user") .. "\n"
      message = message .. "[*] Password : "  .. Http:Dec("password") .. "\n"
      message = message .. "[*] SNI : " .. Http:Dec("sniHostname") .. "\n"
      message = message .. "[*] Proxy : " .. Http:Dec("remoteProxy") .. "\n"
      message = message .. "[*] Payload : " .. Http:Dec("payload") .. "\n"
      message = message .. "[*] ToolsBy : @EstebanZxx\n" 
    gg.copyText(message, true)
    gg.toast(message .. "\n𝐄𝐒𝐓𝐄𝐁𝐀𝐍𝐙𝐗𝐗 𝐃𝐄𝐂𝐑𝐘𝐏𝐓𝐎𝐑")
    saveEhi(message)
    
    
------------------------------------------------------------------------------------------------------------------------------------------------------------------
    
  
  elseif ehi.tunnelType == "dnstt_ssh" then
      message = ""
      
      message = message .. "𝐄𝐒𝐓𝐄𝐁𝐀𝐍𝐙𝐗𝐗 𝐃𝐄𝐂𝐑𝐘𝐏𝐓𝐎𝐑\n"
      message = message .. "════════════════════\n" 
      message = message .. "[*] DNSType : " .. ehi.dnsType .. "\n"
      message = message .. "[*] DNSTTResolverAddress : " .. Http:Dec("dnsttDnsResolverAddr") .. "\n"
      message = message .. "[*] DNSTTResolverMode : " .. ehi.dnsttResolverMode .. "\n"
      message = message .. "[*] DNSTTResolverProvile : " .. ehi.dnsttResolverProfile .. "\n"
      if ehi.overwriteServerData ~= "" then
      serverData = json.parse(ehi.overwriteServerData)
      message = message .. "[*] ServerEvozi : " .. serverData.name .. " (" .. serverData.ip .. ")\n"
      message = message .. "[*] PortEvozi : " .. serverData.sshPort .. "SSH, " .. serverData.sshSslPort .. "\n"
      end
      message = message .. "[*] HostDNSTT : " .. Http:Dec("user") .. "\n"
      message = message .. "[*] PasswordDNSTT : " .. Http:Dec("password") .. "\n"
      message = message .. "[*] NameserverDNSTT : " .. Http:Dec("dnsttNameserver") .. "\n"
      message = message .. "[*] PubkeyDNSTT : " .. Http:Dec("dnsttPublicKey") .. "\n"
      message = message .. "[*] ToolsBy : @EstebanZxx\n" 
    gg.copyText(message, true)
    gg.toast(message .. "\n𝐄𝐒𝐓𝐄𝐁𝐀𝐍𝐙𝐗𝐗 𝐃𝐄𝐂𝐑𝐘𝐏𝐓𝐎𝐑")
    saveEhi(message)
    
    
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------
    
    
elseif ehi.tunnelType == "direct_shadowsocks" then
      message = ""
      
      message = message .. "𝐄𝐒𝐓𝐄𝐁𝐀𝐍𝐙𝐗𝐗 𝐃𝐄𝐂𝐑𝐘𝐏𝐓𝐎𝐑\n"
      message = message .. "════════════════════\n" 
      if ehi.overwriteServerData ~= "" then
      serverData = json.parse(ehi.overwriteServerData)
      message = message .. "[*] ServerEvozi : " .. serverData.name .. " (" .. serverData.ip .. ")\n"
      message = message .. "[*] PortEvozi : " .. serverData.sshPort .. "SSH, " .. serverData.sshSslPort .. "\n"
      end
      message = message .. "[*] ShadowsocksEncMethod : " .. ehi.shadowsocksEncryptionMethod .. "\n"
      message = message .. "[*] ShadowsocksHost : " .. Http:Dec("shadowsocksHost") .. "\n" 
      message = message .. "[*] ShadowsocksPassword : " .. Http:Dec("shadowsocksPassword") .. "\n" 
      message = message .. "[*] ShadowsocksPort : " .. ehi.shadowsocksPort .. "\n"
      message = message .. "[*] ToolsBy : @EstebanZxx\n" 
    gg.copyText(message, true)
    gg.toast(message .. "\n𝐄𝐒𝐓𝐄𝐁𝐀𝐍𝐙𝐗𝐗 𝐃𝐄𝐂𝐑𝐘𝐏𝐓𝐎𝐑")
    saveEhi(message)
    
    
    
------------------------------------------------------------------------------------------------------------------------------------------------------------------

    
elseif ehi.tunnelType == "http_obfs_shadowsocks" then
      message = ""
      
      message = message .. "𝐄𝐒𝐓𝐄𝐁𝐀𝐍𝐙𝐗𝐗 𝐃𝐄𝐂𝐑𝐘𝐏𝐓𝐎𝐑\n"
      message = message .. "════════════════════\n" 
       if ehi.overwriteServerData ~= "" then
      serverData = json.parse(ehi.overwriteServerData)
      message = message .. "[*] ServerEvozi : " .. serverData.name .. " (" .. serverData.ip .. ")\n"
      message = message .. "[*] PortEvozi : " .. serverData.sshPort .. "SSH, " .. serverData.sshSslPort .. "\n"
      end 
      message = message .. "[*] ShadowsocksEncMethod : " .. ehi.shadowsocksEncryptionMethod .. "\n"
      message = message .. "[*] ShadowsocksHost : " .. Http:Dec("shadowsocksHost") .. "\n" 
      message = message .. "[*] ShadowsocksPassword : " .. Http:Dec("shadowsocksPassword") .. "\n" 
      message = message .. "[*] ShadowsocksPort : " .. ehi.shadowsocksPort .. "\n"
      message = message .. "[*] HttpObfsSettings : " .. Http:Dec("httpObfsSettings") .. "\n" 
      message = message .. "[*] ToolsBy : @EstebanZxx\n" 
    gg.copyText(message, true)
    gg.toast(message .. "\n𝐄𝐒𝐓𝐄𝐁𝐀𝐍𝐙𝐗𝐗 𝐃𝐄𝐂𝐑𝐘𝐏𝐓𝐎𝐑")
    saveEhi(message)


-----------------------------------------------------------------------------------------------------------------------------------------------------------------
         
     
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------  
 
  elseif ehi.tunnelType == "direct_v2r_vmess" then
    if ehi.v2rRawJson then
      v2json = Http:Dec("v2rRawJson")
      save(v2json)
      print("V2Ray Settings: /sdcard/decrypt.txt")
      gg.toast(message .. "\n𝐄𝐒𝐓𝐄𝐁𝐀𝐍𝐙𝐗𝐗 𝐃𝐄𝐂𝐑𝐘𝐏𝐓𝐎𝐑")
      gg.copyText(v2json, true)
      gg.sleep(1)
      return
    end
    message = ""
    
    message = message .. "𝐄𝐒𝐓𝐄𝐁𝐀𝐍𝐙𝐗𝐗 𝐃𝐄𝐂𝐑𝐘𝐏𝐓𝐎𝐑\n"
    message = message .. "════════════════════\n" 
    message = message .. "[*] Protocol : " .. Http:Dec("v2rProtocol") .. "\n"
    message = message .. "[*] Host : " .. Http:Dec("v2rHost") .. "\n"
    message = message .. "[*] Port : " .. Http:Dec("v2rPort") .. "\n"
    message = message .. "[*] UserID : " .. Http:Dec("v2rUserId") .. "\n"
    message = message .. "[*] AlterID : " .. Http:Dec("v2rAlterId") .. "\n"
    message = message .. "[*] Security : " .. Http:Dec("v2rVlessSecurity") .. "\n"
    if ehi.v2rNetwork and ehi.v2rNetwork ~= "" then
      message = message .. "[*] NetworkType : " .. Http:Dec("v2rNetwork") .. "\n"
    end
    if ehi.v2rWsHeader and ehi.v2rWsHeader ~= "" then
      message = message .. "[*] Header : " .. Http:Dec("v2rWsHeader") .. "\n"
    end
    if ehi.v2rWsPath and ehi.v2rWsPath ~= "" then
      message = message .. "[*] Path : " .. Http:Dec("v2rWsPath") .. "\n"
    end
    if ehi.v2rTlsSni and ehi.v2rTlsSni ~= "" then
      message = message .. "[*] SNI : " .. Http:Dec("v2rTlsSni") .. "\n"
    end
    message = message .. "[*] ToolsBy : @EstebanZxx\n" 
    gg.copyText(message, true)
    gg.toast(message .. "\n𝐄𝐒𝐓𝐄𝐁𝐀𝐍𝐙𝐗𝐗 𝐃𝐄𝐂𝐑𝐘𝐏𝐓𝐎𝐑")
    saveEhi(message)
  end
  return (Menu)
end

-----------------------------------------------------------------------------------------------------
-- 𝐑𝐞𝐬𝐩𝐞𝐜𝐭 𝐂𝐫𝐞𝐚𝐭𝐨𝐫𝐬. 𝐃𝐨𝐧'𝐭 𝐑𝐞𝐦𝐨𝐯𝐞 𝐂𝐫𝐞𝐝𝐢𝐭 𝐌𝐨𝐝𝐮𝐥𝐞𝐬..!!
-- 𝐂𝐨𝐝𝐞𝐝 𝐁𝐲 : 𝐄𝐒𝐓𝐄𝐁𝐀𝐍_𝐙𝐗𝐗
-----------------------------------------------------------------------------------------------------

function HTTPInjector()
  limit = true
  gg.clearResults()
  gg.setVisible(false)
  gg.setRanges(gg.REGION_C_ALLOC)
  gg.searchNumber("h 7B 22 63 6F 6E 66 69 67 45 78 70 69 72 79 54 69 6D 65 73 74", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1)
  if #r < 1 then
    gg.toast("⚠ Metode 1 Gagal")
    hi_method2 = true
  end
  if hi_method2 then
    gg.searchNumber("h 7B 22 63 6F 6E 66 69 67 49 64 65 6E 74 69 66 69 65 72 22 3A", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      return (Menu)
    end
  end
  gg.searchNumber("h7B", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1000)
  readedMem = rwmem(r[1].address, 50000)
  save(hexdecode(readedMem))
  do
    do
      for SRD1_5_, SRD1_6_ in ipairs(r) do
        r[SRD1_5_].flags = gg.TYPE_FLOAT
        r[SRD1_5_].value = "1000"
      end
    end
  end
  gg.setValues(r)
  gg.clearResults()
  parseHttpInjector(readedMem)
end

-----------------------------------------------------------------------------------------------------
-- 𝐑𝐞𝐬𝐩𝐞𝐜𝐭 𝐂𝐫𝐞𝐚𝐭𝐨𝐫𝐬. 𝐃𝐨𝐧'𝐭 𝐑𝐞𝐦𝐨𝐯𝐞 𝐂𝐫𝐞𝐝𝐢𝐭 𝐌𝐨𝐝𝐮𝐥𝐞𝐬..!!
-- 𝐂𝐨𝐝𝐞𝐝 𝐁𝐲 : 𝐄𝐒𝐓𝐄𝐁𝐀𝐍_𝐙𝐗𝐗
-----------------------------------------------------------------------------------------------------

function BypassPassword()
  limit = false
  function rwmem(Address, SizeOrBuffer)
    assert(Address ~= nil, "[rwmem]: error, provided address is nil.")
    _rw = {}
    if type(SizeOrBuffer) == "number" then
      _ = ""
      do
        do
          for _FORV_5_ = 1, SizeOrBuffer do
            _rw[_FORV_5_] = {
              address = Address - 1 + _FORV_5_,
              flags = gg.TYPE_BYTE
            }
          end
        end
      end
      do
        do
          for _FORV_5_, _FORV_6_ in ipairs(gg.getValues(_rw)) do
            if _FORV_6_.value == 0 and limit == true then
              return _
            end
            _ = _ .. string.format("%02X", _FORV_6_.value & 255)
          end
        end
      end
      return _
    end
    Byte = {}
    SizeOrBuffer:gsub("..", function(x)
      Byte[#Byte + 1] = x
      _rw[#Byte] = {
        address = Address - 1 + #Byte,
        flags = gg.TYPE_BYTE,
        value = x .. "h"
      }
    end
    )
    gg.setValues(_rw)
  end
  
  function hexdecode(hex)
    return (hex:gsub("%x%x", function(digits)
      return string.char(tonumber(digits, 16))
    end
    ))
  end
  
  function hexencode(str)
    return (str:gsub(".", function(char)
      return string.format("%2x", char:byte())
    end
    ))
  end
  
  function Dec2Hex(nValue)
    nHexVal = string.format("%X", nValue)
    sHexVal = nHexVal .. ""
    return sHexVal
  end
  
  function ToInteger(number)
    return math.floor(tonumber(number) or error("Could not cast '" .. tostring(number) .. "' to number.'"))
  end
  
  function save(data)
    local function hexencode_spasi(str)
      return (str:gsub(".", function(char)
          return string.format("%02x ", char:byte())
      end))
    end

    local function checkMatch(key, str)
      result = nil
      
      for index, value in ipairs(key) do
          result = str:match(value)
          if result then 
              break 
          end
      end
      
      return result
    end

    local function strip(s)
      return (s:gsub("^%s*(.-)%s*$", "%1"))
    end

    local function prosesData(data)

      local function findExpDate(tbl)
          local key = {
              "%d%d%d%d[\45]%d%d[\45]%d%d[\32]%d%d[\58]%d%d",
              "lifeTime"
          } 
          local result = nil
          
          for index_tbl, value_tbl in ipairs(tbl) do
  
              for index_key, value_key in ipairs(key) do
                  
                  if value_tbl:match(value_key) then
                      result = index_tbl
                  end
  
              end
          end
          return result
      end
  
      local function splitString(str, separator)
          local match_1, match_2 = str:match("(.-)"..separator.."(.*)")
          local tbl = {}
  
          no = 1
          while (match_2:match("(.-)"..separator.."(.*)") and no < 100) do
      
              match_1, match_2 = match_2:match("(.-)"..separator.."(.*)")
      
              if hexdecode(match_1):match("[^\x20]+") then
                  -- print(no.." : "..strip(hexdecode(match_1):gsub("[^\x20-\x7e]+","")))
                  table.insert(tbl, strip(hexdecode(match_1):gsub("[^\x20-\x7e]+","")))
              else 
                  -- print(no.." : KOSONG ANJING")
                  table.insert(tbl,"")
              end
              
              -- print()
              no = no + 1
              -- print(hexdecode(match_1):gsub("[^\x20-\x7e]+",""))
          end
  
          return tbl
      end
  
      local function fixedConfig(index, tbl)
          local result_fixedConfig = {}
          local beginIndex = index - 4
          local lastIndex = beginIndex + 31
  
          for i = beginIndex, lastIndex do
              table.insert(result_fixedConfig, tbl[i])
          end
  
          return result_fixedConfig
      end
      data = hexencode_spasi(data)
      data = data:gsub("00", "20")
      data = data:gsub("20", "z")
      data = data:gsub("66 61 6c 73 65", "F A L S E")
      data = data:gsub("\x20", "")
      data = data:gsub("\n", "")
      local separator = data:match("FALSE[\x7a]+(.-)[\x7a]+")
      data = data:gsub(separator, "0a56616c647947616e74656e67")
      separator = "0a56616c647947616e74656e67"
      data = data:gsub("z", "20")
      data = data:gsub("FALSE", "66616c7365")

      local result = splitString(data, separator)
      local assemblyPointIndex = findExpDate(result)
      local getConfig = fixedConfig(assemblyPointIndex, result)
  
      return getConfig
    end

    local function getOutput(tbl)
      local cfgRegex = {
        [22] = {
            ["name"] = "[*] 𝐏𝐚𝐬𝐬𝐰𝐨𝐫𝐝𝐕𝐚𝐥𝐮𝐞𝐈",
            ["regex"] = "(.*)"
        },
        [23] = {
            ["name"] = "[*] 𝐏𝐚𝐬𝐬𝐰𝐨𝐫𝐝𝐕𝐚𝐥𝐮𝐞𝐈𝐈",
            ["regex"] = "(.*)"
        }
    }
      
      
            local message = "╔═╗──╔═╦═╗───────╔╗╔══╗────╔═╗\n║╬╠═╗║═╣═╬╦╦╦═╦╦╦╝║╚╗╔╩╦═╦╗║═╣\n║╔╣╬╚╬═╠═║║║║╬║╔╣╬║─║║╬║╬║╚╬═║\n╚╝╚══╩═╩═╩══╩═╩╝╚═╝─╚╩═╩═╩═╩═╝\n───────────────────────────────\n"
  
      for index, value in ipairs(tbl) do
          
          if cfgRegex[index] and value:match(cfgRegex[index]["regex"]) then
              local namaKonten = cfgRegex[index]["name"]
              local valueRegexKonten = value:match(cfgRegex[index]["regex"])
  
              -- print(namaKonten.." ► "..valueRegexKonten.."\n")
              message = message..namaKonten.." : "..valueRegexKonten.."\n"
          end
          
      end
  
      message = message.."───────────────────────────────"
      return message
    end


    local contentToDecrypt = hexdecode(data)
    contentToDecrypt = prosesData(hexdecode(data))
    local hasil = getOutput(contentToDecrypt)
    io.open(gg.EXT_STORAGE .. "/decrypt.txt", "w"):write(data)
    gg.alert(hasil)
    gg.copyText(hasil, false)
    gg.toast("✓ Decrypt Success And Result Copied To Clipboard..!!")
  end
  
  gg.setRanges(gg.REGION_JAVA_HEAP)
  gg.searchNumber(":[splitPsiphon][splitPsiphon]", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1)
  if #r < 1 then
    gg.toast("✖ Method 1 failed")
    hc_method2 = true
  end
  if hc_method2 then
    gg.searchNumber(":[splitPsiphon]", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("✖ Method 2 failed")
      hc_method3 = true
    end
  end
  
  if hc_method3 then
    print("✖ All methods failed")
    return (Menu)
  end
  local r = gg.getResults(11)
  if limit == false then
    r[1].address = r[1].address - 1000
  end
  readedMem = rwmem(r[1].address, 10000)
  save(readedMem)
  gg.clearResults()
end

function ManualDump()
function rwmem(Address, SizeOrBuffer)
  assert(Address ~= nil, "[rwmem]: error, provided address is nil.")
  _rw = {}
  if type(SizeOrBuffer) == "number" then
    _ = ""
    do
      do
        for i = 1, SizeOrBuffer do
          _rw[i] = {
            address = Address - 1 + i,
            flags = gg.TYPE_BYTE
          }
        end--𝐃𝐞𝐜 𝐁𝐲 𝐀𝐬𝐡𝐫𝐚𝐟(Fᴏʀ)
      end--𝐃𝐞𝐜 𝐁𝐲 𝐀𝐬𝐡𝐫𝐚𝐟(Dᴏ)
    end--𝐃𝐞𝐜 𝐁𝐲 𝐀𝐬𝐡𝐫𝐚𝐟(Dᴏ)
    do
      do
        for i, i in ipairs(gg.getValues(_rw)) do
          if i.value == 0 then
          end--𝐃𝐞𝐜 𝐁𝐲 𝐀𝐬𝐡𝐫𝐚𝐟(Iғ)
          _ = _ .. string.format("%02X", i.value & 255)
        end--𝐃𝐞𝐜 𝐁𝐲 𝐀𝐬𝐡𝐫𝐚𝐟(Fᴏʀ)
      end--𝐃𝐞𝐜 𝐁𝐲 𝐀𝐬𝐡𝐫𝐚𝐟(Dᴏ)
    end--𝐃𝐞𝐜 𝐁𝐲 𝐀𝐬𝐡𝐫𝐚𝐟(Dᴏ)
    return _
  end--𝐃𝐞𝐜 𝐁𝐲 𝐀𝐬𝐡𝐫𝐚𝐟(Iғ)
  Byte = {}
  SizeOrBuffer:gsub("..", function(x)
    Byte[#Byte + 1] = x
    _rw[#Byte] = {
      address = Address - 1 + #Byte,
      flags = gg.TYPE_BYTE,
      value = x .. "h"
    }
  end--𝐃𝐞𝐜 𝐁𝐲 𝐀𝐬𝐡𝐫𝐚𝐟(Fᴜɴᴄᴛɪᴏɴ)
  )
  gg.setValues(_rw)
end--𝐃𝐞𝐜 𝐁𝐲 𝐀𝐬𝐡𝐫𝐚𝐟(Fᴜɴᴄᴛɪᴏɴ)

local hexdecode = function(hex)
  return (hex:gsub("%x%x", function(digits)
    return string.char(tonumber(digits, 16))
  end--𝐃𝐞𝐜 𝐁𝐲 𝐀𝐬𝐡𝐫𝐚𝐟(Fᴜɴᴄᴛɪᴏɴ)
  ))
end--𝐃𝐞𝐜 𝐁𝐲 𝐀𝐬𝐡𝐫𝐚𝐟(Fᴜɴᴄᴛɪᴏɴ)

local hexencode = function(str)
  return (str:gsub(".", function(char)
    return string.format("%2x", char:byte())
  end--𝐃𝐞𝐜 𝐁𝐲 𝐀𝐬𝐡𝐫𝐚𝐟(Fᴜɴᴄᴛɪᴏɴ)
  ))
end--𝐃𝐞𝐜 𝐁𝐲 𝐀𝐬𝐡𝐫𝐚𝐟(Fᴜɴᴄᴛɪᴏɴ)

gg.clearResults()
options = gg.prompt({"Address"}, {
  [1] = ""
}, {
  [1] = "text"
})
gg.setRanges(gg.REGION_C_ALLOC)
readedMem = rwmem("0x" .. options[1], 70000)
io.open(gg.EXT_STORAGE .. "/decrypt.txt", "w"):write(hexdecode(readedMem))
gg.clearResults()
return (Menu)
end

-----------------------------------------------------------------------------------------------------
-- 𝐑𝐞𝐬𝐩𝐞𝐜𝐭 𝐂𝐫𝐞𝐚𝐭𝐨𝐫𝐬. 𝐃𝐨𝐧'𝐭 𝐑𝐞𝐦𝐨𝐯𝐞 𝐂𝐫𝐞𝐝𝐢𝐭 𝐌𝐨𝐝𝐮𝐥𝐞𝐬..!!
-- 𝐂𝐨𝐝𝐞𝐝 𝐁𝐲 : 𝐄𝐒𝐓𝐄𝐁𝐀𝐍_𝐙𝐗𝐗
-----------------------------------------------------------------------------------------------------

while true do
  if gg.isVisible(true) then
    Lua = 1
    gg.setVisible(false)
    end
  if Lua == 1 then
    Irene()
    end
    end

-----------------------------------------------------------------------------------------------------
-- 𝐑𝐞𝐬𝐩𝐞𝐜𝐭 𝐂𝐫𝐞𝐚𝐭𝐨𝐫𝐬. 𝐃𝐨𝐧'𝐭 𝐑𝐞𝐦𝐨𝐯𝐞 𝐂𝐫𝐞𝐝𝐢𝐭 𝐌𝐨𝐝𝐮𝐥𝐞𝐬..!!
-- 𝐂𝐨𝐝𝐞𝐝 𝐁𝐲 : 𝐄𝐒𝐓𝐄𝐁𝐀𝐍_𝐙𝐗𝐗
-----------------------------------------------------------------------------------------------------
