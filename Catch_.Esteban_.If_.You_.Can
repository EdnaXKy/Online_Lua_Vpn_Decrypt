
-----------------------------------------------------------------------------------------------------
-- ğ‘ğğ¬ğ©ğğœğ­ ğ‚ğ«ğğšğ­ğ¨ğ«ğ¬. ğƒğ¨ğ§'ğ­ ğ‘ğğ¦ğ¨ğ¯ğ ğ‚ğ«ğğğ¢ğ­ ğŒğ¨ğğ®ğ¥ğğ¬..!!
-- ğ‚ğ¨ğğğ ğğ² : ğ„ğ’ğ“ğ„ğğ€ğ_ğ™ğ—ğ—
-----------------------------------------------------------------------------------------------------

gg.getTargetInfo(packageName)
gg.toast("âœ” ğ’ğœğ«ğ¢ğ©ğ­ ğ€ğœğ­ğ¢ğ¯ğğ")
gg.setVisible(false)
gg.sleep(200)
gg.clearResults()
gg.setVisible(true)

-----------------------------------------------------------------------------------------------------
-- ğ‘ğğ¬ğ©ğğœğ­ ğ‚ğ«ğğšğ­ğ¨ğ«ğ¬. ğƒğ¨ğ§'ğ­ ğ‘ğğ¦ğ¨ğ¯ğ ğ‚ğ«ğğğ¢ğ­ ğŒğ¨ğğ®ğ¥ğğ¬..!!
-- ğ‚ğ¨ğğğ ğğ² : ğ„ğ’ğ“ğ„ğğ€ğ_ğ™ğ—ğ—
-----------------------------------------------------------------------------------------------------

function Irene()
  Menu = gg.choice({
    "ã€˜ â– ã€™  â£   â§¼  ğ‡ğ“ğ“ğ ğ‚ğ®ğ¬ğ­ğ¨ğ¦  â§½", -- 1
    "ã€˜ â– ã€™  â£   â§¼  ğ‡ğ“ğ“ğ ğˆğ§ğ£ğğœğ­ğ¨ğ«  â§½", -- 2
    "ã€˜ â– ã€™  â£   â§¼  ğ“ğ‹ğ’ ğ“ğ®ğ§ğ§ğğ¥  â§½", -- 3
    "ã€˜ â– ã€™  â£   â§¼  ğğğ•ğŸ’ ğŒğğ§ğ®  â§½", -- 4
    "ã€˜ â– ã€™  â£   â§¼  ğƒğšğ«ğ¤ ğ“ğ®ğ§ğ§ğğ¥  â§½", -- 5
    "ã€˜ â– ã€™  â£   â§¼  Manual Dump  â§½", -- 5
    "ã€˜ â– ã€™  â£   â§¼  ğ‚ğ«ğğğ¢ğ­ ğŒğ¨ğğ®ğ¥ğğ¬  â§½", -- 5
    "ã€˜ âœ– ã€™  â£   â§¼  ğ„ğ±ğ¢ğ­ ğ’ğœğ«ğ¢ğ©ğ­  â§½" -- 7
}, nil, os.date(
"â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â€ƒâ€ƒâ–ˆâ–ˆâ•—â–‘â–‘â–ˆâ–ˆâ•—â€ƒâ€ƒâ–ˆâ–ˆâ•—â–‘â–‘â–ˆâ–ˆâ•—\nâ•šâ•â•â•â•â–ˆâ–ˆâ•‘â€ƒâ€ƒâ•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â€ƒâ€ƒâ•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•\nâ–‘â–‘â–ˆâ–ˆâ–ˆâ•”â•â•â€ƒâ€ƒâ–‘â•šâ–ˆâ–ˆâ–ˆâ•”â•â–‘â€ƒâ€ƒâ–‘â•šâ–ˆâ–ˆâ–ˆâ•”â•â–‘\nâ–ˆâ–ˆâ•”â•â•â•â–‘â–‘â€ƒâ€ƒâ–‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•—â–‘â€ƒâ€ƒâ–‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•—â–‘\nâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â€ƒâ€ƒâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ•—â€ƒâ€ƒâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ•—\nâ•šâ•â•â•â•â•â•â•â€ƒâ€ƒâ•šâ•â•â–‘â–‘â•šâ•â•â€ƒâ€ƒâ•šâ•â•â–‘â–‘â•šâ•â•\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ‹† ğ™ğ—ğ— â€¢ ğƒğ„ğ‚ğ‘ğ˜ğğ“ğğ‘ ğ“ğğğ‹ğ’\nâ‹† ğ’ğœğ«ğ¢ğ©ğ­ ğ•ğğ«ğ¬ğ¢ğ¨ğ§ã€š ğŸ.ğŸ.ğŸ ğğğ­ğšğ“ğğ¬ğ­ ã€›\nâ‹† ğ‚ğ¨ğğğ ğğ² : ğ„ğ’ğ“ğ„ğğ€ğ_ğ™ğ—ğ— - ğŠğŒğŠğ™ ğŸğŸğŸ ğ– ™ á¯“\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
))

-----------------------------------------------------------------------------------------------------
-- ğ‘ğğ¬ğ©ğğœğ­ ğ‚ğ«ğğšğ­ğ¨ğ«ğ¬. ğƒğ¨ğ§'ğ­ ğ‘ğğ¦ğ¨ğ¯ğ ğ‚ğ«ğğğ¢ğ­ ğŒğ¨ğğ®ğ¥ğğ¬..!!
-- ğ‚ğ¨ğğğ ğğ² : ğ„ğ’ğ“ğ„ğğ€ğ_ğ™ğ—ğ—
-----------------------------------------------------------------------------------------------------

if Menu == nil then
else
if Menu == 1 then
HTTPCustom()
end
if Menu == 2 then
HTTPInjector()
end
if Menu == 3 then
TlsTunnel()
end
if Menu == 4 then
NPV4Menu()
end
if Menu == 5 then
DarkTunnel()
end
if Menu == 6 then
ManualDump()
end
if Menu == 7 then
CreditModules()
end
if Menu == 8 then
ExitScript()
end
end
Lua = -1
end

-----------------------------------------------------------------------------------------------------
-- ğ‘ğğ¬ğ©ğğœğ­ ğ‚ğ«ğğšğ­ğ¨ğ«ğ¬. ğƒğ¨ğ§'ğ­ ğ‘ğğ¦ğ¨ğ¯ğ ğ‚ğ«ğğğ¢ğ­ ğŒğ¨ğğ®ğ¥ğğ¬..!!
-- ğ‚ğ¨ğğğ ğğ² : ğ„ğ’ğ“ğ„ğğ€ğ_ğ™ğ—ğ—
-----------------------------------------------------------------------------------------------------

function HTTPCustom()
  HC = gg.choice({
    "ã€˜ â– ã€™  â£   â§¼  ğğ²ğ©ğšğ¬ğ¬ ğğšğ¬ğ¬ğ°ğ¨ğ«ğ  â§½",
    "ã€˜ â– ã€™  â£   â§¼  ğ€ğ®ğ­ğ¨ğğ«ğ¢ğ§ğ­ ğˆ  â§½",
    "ã€˜ â– ã€™  â£   â§¼  ğƒğğœğ«ğ²ğ©ğ­ ğˆ  â§½",
    "ã€˜ â– ã€™  â£   â§¼  ğƒğğœğ«ğ²ğ©ğ­ ğˆğˆ  â§½",
    "ã€˜ â– ã€™  â£   â§¼  ğğ¬ğ¢ğ©ğ¡ğ¨ğ§ ğ€ğ®ğ­ğ¡ğ¨ğ«ğ¢ğ³ğ¨ğ§  â§½",
    "ã€˜ âœ– ã€™  â£   â§¼  ğğšğœğ¤  â§½"
}, nil, os.date(
"â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—â–‘â–‘â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—â–‘â–‘â–ˆâ–ˆâ•—\nâ•šâ•â•â•â•â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•\nâ–‘â–‘â–ˆâ–ˆâ–ˆâ•”â•â•â–‘â•šâ–ˆâ–ˆâ–ˆâ•”â•â–‘â–‘â•šâ–ˆâ–ˆâ–ˆâ•”â•\nâ–ˆâ–ˆâ•”â•â•â•â–‘â–‘â–‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•—â–‘â–‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•—\nâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ•—\nâ•šâ•â•â•â•â•â•â•â•šâ•â•â–‘â–‘â•šâ•â•â•šâ•â•â–‘â–‘â•šâ•â•\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ‹† ğ‡ğ‚ ğ“ğ¨ğ¨ğ¥ğ¬ ğƒğğœğ«ğ²ğ©ğ­ğ¨ğ«\nâ‹† ğ•ğğ«ğ¬ğ¢ğ¨ğ§ã€š ğŸ‘.ğŸ ã€›\nâ‹† ğ‚ğ¨ğğğ ğğ² : ğ„ğ’ğ“ğ„ğğ€ğ_ğ™ğ—ğ— - ğŠğŒğŠğ™ ğŸğŸğŸ ğ– ™ á¯“\n"
))

-----------------------------------------------------------------------------------------------------
-- ğ‘ğğ¬ğ©ğğœğ­ ğ‚ğ«ğğšğ­ğ¨ğ«ğ¬. ğƒğ¨ğ§'ğ­ ğ‘ğğ¦ğ¨ğ¯ğ ğ‚ğ«ğğğ¢ğ­ ğŒğ¨ğğ®ğ¥ğğ¬..!!
-- ğ‚ğ¨ğğğ ğğ² : ğ„ğ’ğ“ğ„ğğ€ğ_ğ™ğ—ğ—
-----------------------------------------------------------------------------------------------------

if HC == nil then
else
if HC == 1 then
BypassPassword()
end
if HC == 2 then
AutoPrintI()
end
if HC == 3 then
DecI()
end
if HC == 4 then
DecII()
end
if HC == 5 then
PsiphonAuth()
end
if HC == 6 then
Irene()
end
end
Lua = -1
end

-----------------------------------------------------------------------------------------------------
-- ğ‘ğğ¬ğ©ğğœğ­ ğ‚ğ«ğğšğ­ğ¨ğ«ğ¬. ğƒğ¨ğ§'ğ­ ğ‘ğğ¦ğ¨ğ¯ğ ğ‚ğ«ğğğ¢ğ­ ğŒğ¨ğğ®ğ¥ğğ¬..!!
-- ğ‚ğ¨ğğğ ğğ² : ğ„ğ’ğ“ğ„ğğ€ğ_ğ™ğ—ğ—
-----------------------------------------------------------------------------------------------------

function NPV4Menu()
  NPV4 = gg.choice({
    "ã€˜ â– ã€™  â£   â§¼  ğƒğğœğ«ğ²ğ©ğ­ ğğšğ©ğ¬ğ­ğğ«ğ§ğğ­ğ•  â§½",
    "ã€˜ â– ã€™  â£   â§¼  ğ‘ğğ¬ğ®ğ¥ğ­ ğğšğ©ğ¬ğ­ğğ«ğ§ğğ­ğ•  â§½",
    "ã€˜ âœ– ã€™  â£   â§¼  ğğšğœğ¤  â§½"
}, nil, os.date(
"â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—â–‘â–‘â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—â–‘â–‘â–ˆâ–ˆâ•—\nâ•šâ•â•â•â•â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•\nâ–‘â–‘â–ˆâ–ˆâ–ˆâ•”â•â•â–‘â•šâ–ˆâ–ˆâ–ˆâ•”â•â–‘â–‘â•šâ–ˆâ–ˆâ–ˆâ•”â•\nâ–ˆâ–ˆâ•”â•â•â•â–‘â–‘â–‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•—â–‘â–‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•—\nâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ•—\nâ•šâ•â•â•â•â•â•â•â•šâ•â•â–‘â–‘â•šâ•â•â•šâ•â•â–‘â–‘â•šâ•â•\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ‹† ğğğ•ğŸ’ ğ“ğ¨ğ¨ğ¥ğ¬ ğƒğğœğ«ğ²ğ©ğ­ğ¨ğ«\nâ‹† ğ•ğğ«ğ¬ğ¢ğ¨ğ§ã€š ğŸ.ğŸ ã€›\nâ‹† ğ‚ğ¨ğğğ ğğ² : ğ„ğ’ğ“ğ„ğğ€ğ_ğ™ğ—ğ— - ğŠğŒğŠğ™ ğŸğŸğŸ ğ– ™ á¯“\n"
))

if NPV4 == nil then
else
if NPV4 == 1 then
NapsternetV()
end
if NPV4 == 2 then
ResultNapsternetV()
end
if NPV4 == 3 then
Irene()
end
end
Lua = -1
end
-----------------------------------------------------------------------------------------------------
-- ğ‘ğğ¬ğ©ğğœğ­ ğ‚ğ«ğğšğ­ğ¨ğ«ğ¬. ğƒğ¨ğ§'ğ­ ğ‘ğğ¦ğ¨ğ¯ğ ğ‚ğ«ğğğ¢ğ­ ğŒğ¨ğğ®ğ¥ğğ¬..!!
-- ğ‚ğ¨ğğğ ğğ² : ğ„ğ’ğ“ğ„ğğ€ğ_ğ™ğ—ğ—
-----------------------------------------------------------------------------------------------------

limit = false
function rwmem(Address, SizeOrBuffer)
	assert(Address ~= nil, "[rwmem]: error, provided address is nil.")
	_rw = {}
	if type(SizeOrBuffer) == "number" then
		_ = ""
		for _ = 1, SizeOrBuffer do _rw[_] = {address = (Address - 1) + _, flags = gg.TYPE_BYTE} end
		for v, __ in ipairs(gg.getValues(_rw)) do
		  if __.value == 00 and limit == true then
		    return _
		  end
		  _ = _ .. string.format("%02X", __.value & 0xFF)
		  -- payload = payload .. string.char(__.value)
        end
		return _
	end
	Byte = {} SizeOrBuffer:gsub("..", function(x) 
		Byte[#Byte + 1] = x _rw[#Byte] = {address = (Address - 1) + #Byte, flags = gg.TYPE_BYTE, value = x .. "h"} 
	end)
	gg.setValues(_rw)
end

function hexdecode(hex)
   return (hex:gsub("%x%x", function(digits) return string.char(tonumber(digits, 16)) end))
end

function hexencode(str)
   return (str:gsub(".", function(char) return string.format("%2x", char:byte()) end))
end

function Dec2Hex(nValue)
	nHexVal = string.format("%X", nValue);
	sHexVal = nHexVal.."";
	return sHexVal;
end

function ToInteger(number)
    return math.floor(tonumber(number) or error("Could not cast '" .. tostring(number) .. "' to number.'"))
end

-----------------------------------------------------------------------------------------------------
-- ğ‘ğğ¬ğ©ğğœğ­ ğ‚ğ«ğğšğ­ğ¨ğ«ğ¬. ğƒğ¨ğ§'ğ­ ğ‘ğğ¦ğ¨ğ¯ğ ğ‚ğ«ğğğ¢ğ­ ğŒğ¨ğğ®ğ¥ğğ¬..!!
-- ğ‚ğ¨ğğğ ğğ² : ğ„ğ’ğ“ğ„ğğ€ğ_ğ™ğ—ğ—
-----------------------------------------------------------------------------------------------------

function DecI()
function save(data)
    io.open(gg.EXT_STORAGE .. "/decrypt.txt", "w"):write(hexdecode(data))
    gg.toast("âœ“ ğƒğğœğ«ğ²ğ©ğ­ ğ’ğ®ğœğœğğ¬ğ¬ğŸğ®ğ¥")
    gg.alert("â•”â•â•â•—â”€â”€â”€â”€â”€â”€â”€â”€â”€â•”â•—\nâ•šâ•—â•—â• â•â•¦â•â•¦â•¦â•¦â•¦â•¦â•â•£â•šâ•—\nâ•”â•©â•â•‘â•©â•£â•â•£â•”â•£â•‘â•‘â•¬â•‘â•”â•£\nâ•šâ•â•â•©â•â•©â•â•©â•â• â•—â•‘â•”â•©â•â•\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â•šâ•â•©â•\nâ•”â•â•â•—â”€â”€â”€â”€â”€â”€â”€â•”â•â•¦â•â•—\nâ•‘â•â•â•¬â•¦â•¦â•â•¦â•â•¦â•â•£â•â•£â•â•¬â•¦â•¦â•—â•”â•—\nâ• â•â•â•‘â•‘â•‘â•â•£â•â•£â•©â•¬â•â•‘â•”â•£â•‘â•‘â•šâ•£â•šâ•—\nâ•šâ•â•â•©â•â•©â•â•©â•â•©â•â•©â•â•©â•â•šâ•â•©â•â•©â•â•", "ğ˜½ğ™–ğ™˜ğ™  ğ™ˆğ™šğ™£ğ™ª")
    end

    gg.setRanges(gg.REGION_JAVA_HEAP)
    gg.searchNumber("h5b 63 72 6c 66 5d 5b 63 72 6c 66 5d", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
        gg.toast("âœ˜ ğŒğğ­ğ¡ğ¨ğ ğŸ ğ…ğšğ¢ğ¥ğğ")
        hc_method2 = true
        end
    
    
    if hc_method2 then
        gg.searchNumber("h69 6e 62 6f 75 6e 64 73", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
        local r = gg.getResults(1)
        if #r < 1 then
            gg.toast("âœ˜ ğŒğğ­ğ¡ğ¨ğ ğŸ ğ…ğšğ¢ğ¥ğğ")
            hc_method3 = true
            end
            end
    
   
    if hc_method3 then
        gg.searchNumber("h3a 55 70 67 72 61 64 65 3a 20 77 65 62 73 6f 63 6b 65 74", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
        local r = gg.getResults(1)
        if #r < 1 then
            gg.toast("âœ˜ ğŒğğ­ğ¡ğ¨ğ ğŸ‘ ğ…ğšğ¢ğ¥ğğ")
            hc_method4 = true
            end
            end
    
  
    if hc_method4 then
        gg.searchNumber("h5b 73 70 6c 69 74 50 73 69 70 68 6f 6e 5d", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
        local r = gg.getResults(1)
        if #r < 1 then
            gg.toast("âœ˜ ğŒğğ­ğ¡ğ¨ğ ğŸ’ ğ…ğšğ¢ğ¥ğğ")
            hc_method5 = true
            end
            end
    
    if hc_method5 then
        gg.toast("âœ˜ ğƒğğœğ«ğ²ğ©ğ­ ğ…ğšğ¢ğ¥ğğ")
        return (Menu)
        end
        
   
    
    local r = gg.getResults(1)
    if limit == false then
        r[1].address = r[1].address - 8000
        end
    
    readedMem = rwmem(r[1].address, 50000)
    save(readedMem)
    gg.clearResults()
    end

-----------------------------------------------------------------------------------------------------
-- ğ‘ğğ¬ğ©ğğœğ­ ğ‚ğ«ğğšğ­ğ¨ğ«ğ¬. ğƒğ¨ğ§'ğ­ ğ‘ğğ¦ğ¨ğ¯ğ ğ‚ğ«ğğğ¢ğ­ ğŒğ¨ğğ®ğ¥ğğ¬..!!
-- ğ‚ğ¨ğğğ ğğ² : ğ„ğ’ğ“ğ„ğğ€ğ_ğ™ğ—ğ—
-----------------------------------------------------------------------------------------------------

function DecII()
function save(data)
    io.open(gg.EXT_STORAGE .. "/decrypt.txt", "w"):write(hexdecode(data))
    gg.toast("âœ“ ğƒğğœğ«ğ²ğ©ğ­ ğ’ğ®ğœğœğğ¬ğ¬ğŸğ®ğ¥")
    gg.alert("â•”â•â•â•—â”€â”€â”€â”€â”€â”€â”€â”€â”€â•”â•—\nâ•šâ•—â•—â• â•â•¦â•â•¦â•¦â•¦â•¦â•¦â•â•£â•šâ•—\nâ•”â•©â•â•‘â•©â•£â•â•£â•”â•£â•‘â•‘â•¬â•‘â•”â•£\nâ•šâ•â•â•©â•â•©â•â•©â•â• â•—â•‘â•”â•©â•â•\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â•šâ•â•©â•\nâ•”â•â•â•—â”€â”€â”€â”€â”€â”€â”€â•”â•â•¦â•â•—\nâ•‘â•â•â•¬â•¦â•¦â•â•¦â•â•¦â•â•£â•â•£â•â•¬â•¦â•¦â•—â•”â•—\nâ• â•â•â•‘â•‘â•‘â•â•£â•â•£â•©â•¬â•â•‘â•”â•£â•‘â•‘â•šâ•£â•šâ•—\nâ•šâ•â•â•©â•â•©â•â•©â•â•©â•â•©â•â•©â•â•šâ•â•©â•â•©â•â•", "ğ˜½ğ™–ğ™˜ğ™  ğ™ˆğ™šğ™£ğ™ª")
    end

    gg.setRanges(gg.REGION_JAVA_HEAP)
    gg.searchNumber("h22 63 66 67 22 3a 20 7b", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
        gg.toast("âœ˜ ğŒğğ­ğ¡ğ¨ğ ğŸ ğ…ğšğ¢ğ¥ğğ")
        hc_method2 = true
        end
    
    
    if hc_method2 then
        gg.searchNumber("h22 76 65 72 43 66 67 22 3a", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
        local r = gg.getResults(1)
        if #r < 1 then
            gg.toast("âœ˜ ğŒğğ­ğ¡ğ¨ğ ğŸ ğ…ğšğ¢ğ¥ğğ")
            hc_method3 = true
            end
            end
    
   
    if hc_method3 then
        gg.searchNumber("h22 61 22 3a", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
        local r = gg.getResults(1)
        if #r < 1 then
            gg.toast("âœ˜ ğŒğğ­ğ¡ğ¨ğ ğŸ‘ ğ…ğšğ¢ğ¥ğğ")
            hc_method4 = true
            end
            end
    

    if hc_method4 then
        gg.toast("âœ˜ ğƒğğœğ«ğ²ğ©ğ­ ğ…ğšğ¢ğ¥ğğ")
        return (Menu)
        end
        
   
    
local r = gg.getResults(1000)
  if limit == true then
    r[1].address = r[1].address - 8192
  end
  readedMem = rwmem(r[1].address, 30000)
  save(readedMem)
  gg.clearResults()
end

-----------------------------------------------------------------------------------------------------
-- ğ‘ğğ¬ğ©ğğœğ­ ğ‚ğ«ğğšğ­ğ¨ğ«ğ¬. ğƒğ¨ğ§'ğ­ ğ‘ğğ¦ğ¨ğ¯ğ ğ‚ğ«ğğğ¢ğ­ ğŒğ¨ğğ®ğ¥ğğ¬..!!
-- ğ‚ğ¨ğğğ ğğ² : ğ„ğ’ğ“ğ„ğğ€ğ_ğ™ğ—ğ—
-----------------------------------------------------------------------------------------------------

function PsiphonAuth()
function save(data)
    io.open(gg.EXT_STORAGE .. "/decrypt.txt", "w"):write(hexdecode(data))
    gg.toast("âœ“ ğƒğğœğ«ğ²ğ©ğ­ ğ’ğ®ğœğœğğ¬ğ¬ğŸğ®ğ¥")
    gg.alert("â•”â•â•â•—â”€â”€â”€â”€â”€â”€â”€â”€â”€â•”â•—\nâ•šâ•—â•—â• â•â•¦â•â•¦â•¦â•¦â•¦â•¦â•â•£â•šâ•—\nâ•”â•©â•â•‘â•©â•£â•â•£â•”â•£â•‘â•‘â•¬â•‘â•”â•£\nâ•šâ•â•â•©â•â•©â•â•©â•â• â•—â•‘â•”â•©â•â•\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â•šâ•â•©â•\nâ•”â•â•â•—â”€â”€â”€â”€â”€â”€â”€â•”â•â•¦â•â•—\nâ•‘â•â•â•¬â•¦â•¦â•â•¦â•â•¦â•â•£â•â•£â•â•¬â•¦â•¦â•—â•”â•—\nâ• â•â•â•‘â•‘â•‘â•â•£â•â•£â•©â•¬â•â•‘â•”â•£â•‘â•‘â•šâ•£â•šâ•—\nâ•šâ•â•â•©â•â•©â•â•©â•â•©â•â•©â•â•©â•â•šâ•â•©â•â•©â•â•", "ğ˜½ğ™–ğ™˜ğ™  ğ™ˆğ™šğ™£ğ™ª")
    end

    gg.setRanges(gg.REGION_JAVA_HEAP)
    gg.searchNumber("h65 79 4a 42 64 58 52 6f 62 33 4a 70 65 6d 46 30 61 57 39 75 49 6a 70", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
        gg.toast("âœ˜ ğŒğğ­ğ¡ğ¨ğ ğŸ ğ…ğšğ¢ğ¥ğğ")
        hc_method2 = true
        end
    
    
    if hc_method2 then
        gg.toast("âœ˜ ğƒğğœğ«ğ²ğ©ğ­ ğ…ğšğ¢ğ¥ğğ")
        return (HC)
        end
        
   
    
    local r = gg.getResults(11)
    if limit == false then
        r[1].address = r[1].address - 7500
        end
    
    readedMem = rwmem(r[1].address, 50000)
    save(readedMem)
    gg.clearResults()
    end
    
-----------------------------------------------------------------------------------------------------
-- ğ‘ğğ¬ğ©ğğœğ­ ğ‚ğ«ğğšğ­ğ¨ğ«ğ¬. ğƒğ¨ğ§'ğ­ ğ‘ğğ¦ğ¨ğ¯ğ ğ‚ğ«ğğğ¢ğ­ ğŒğ¨ğğ®ğ¥ğğ¬..!!
-- ğ‚ğ¨ğğğ ğğ² : ğ„ğ’ğ“ğ„ğğ€ğ_ğ™ğ—ğ—
-----------------------------------------------------------------------------------------------------

function TlsTunnel()
local utf8 = {}
local bit = {
  data32 = {}
}
do
  do
    for SRD1_5_ = 1, 32 do
      bit.data32[SRD1_5_] = 2 ^ (32 - SRD1_5_)
    end
  end
end
local toby = string.byte
function utf8.charbytes(s, i)
  i = i or 1
  local c = string.byte(s, i)
  if c > 0 and c <= 127 then
    do return 1 end
    return
  end
  if c >= 194 and c <= 223 then
    do return 2 end
    return
  end
  if c >= 224 and c <= 239 then
    do return 3 end
    return
  end
  if c >= 240 and c <= 244 then
    return 4
  end
  return 1
end

local ded
function bit:d2b(arg)
  if arg == nil then
    return
  end
  local tr, c = {}, arg < 0
  if c then
    arg = 0 - arg
  end
  do
    do
      for SRD1_7_ = 1, 32 do
        if arg >= self.data32[SRD1_7_] then
          tr[SRD1_7_] = 1
          arg = arg - self.data32[SRD1_7_]
        else
          tr[SRD1_7_] = 0
        end
      end
    end
  end
  if c then
    tr = self:_bnot(tr)
    tr = self:b2d(tr) + 1
    tr = self:d2b(tr)
  end
  return tr
end

function bit:b2d(arg, neg)
  local nr = 0
  if arg[1] == 1 and neg == true then
    arg = self:_bnot(arg)
    nr = self:b2d(arg) + 1
    nr = 0 - nr
  else
    do
      for SRD1_7_ = 1, 32 do
        if arg[SRD1_7_] == 1 then
          nr = nr + 2 ^ (32 - SRD1_7_)
        end
      end
    end
  end
  return nr
end

function bit:_and(a, b)
  local op1 = self:d2b(a)
  local op2 = self:d2b(b)
  local r = {}
  do
    do
      for SRD1_9_ = 1, 32 do
        if op1[SRD1_9_] == 1 and op2[SRD1_9_] == 1 then
          r[SRD1_9_] = 1
        else
          r[SRD1_9_] = 0
        end
      end
    end
  end
  return self:b2d(r, true)
end

function bit:_or(a, b)
  local op1 = self:d2b(a)
  local op2 = self:d2b(b)
  local r = {}
  do
    do
      for SRD1_9_ = 1, 32 do
        if op1[SRD1_9_] == 1 or op2[SRD1_9_] == 1 then
          r[SRD1_9_] = 1
        else
          r[SRD1_9_] = 0
        end
      end
    end
  end
  return self:b2d(r, true)
end

function bit:_xor(a, b)
  local op1 = self:d2b(a)
  if op1 == nil then
    return nil
  end
  local op2 = self:d2b(b)
  if op2 == nil then
    return nil
  end
  local r = {}
  do
    do
      for SRD1_9_ = 1, 32 do
        if op1[SRD1_9_] == op2[SRD1_9_] then
          r[SRD1_9_] = 0
        else
          r[SRD1_9_] = 1
        end
      end
    end
  end
  return self:b2d(r, true)
end

local switch = {
  [1] = function(s, pos)
    local c1 = toby(s, pos)
    return c1
  end
  ,
  [2] = function(s, pos)
    local c1 = toby(s, pos)
    local c2 = toby(s, pos + 1)
    local int1 = bit:_and(31, c1)
    local int2 = bit:_and(63, c2)
    return bit:_or(bit:_lshift(int1, 6), int2)
  end
  ,
  [3] = function(s, pos)
    local c1 = toby(s, pos)
    local c2 = toby(s, pos + 1)
    local c3 = toby(s, pos + 2)
    local int1 = bit:_and(15, c1)
    local int2 = bit:_and(63, c2)
    local int3 = bit:_and(63, c3)
    local o2 = bit:_or(bit:_lshift(int1, 12), bit:_lshift(int2, 6))
    local dt = bit:_or(o2, int3)
    return dt
  end
  ,
  [4] = function(s, pos)
    local c1 = toby(s, pos)
    local c2 = toby(s, pos + 1)
    local c3 = toby(s, pos + 2)
    local c4 = toby(s, pos + 3)
    local int1 = bit:_and(15, c1)
    local int2 = bit:_and(63, c2)
    local int3 = bit:_and(63, c3)
    local int4 = bit:_and(63, c4)
    local o2 = bit:_or(bit:_lshift(int1, 18), bit:_lshift(int2, 12))
    local o3 = bit:_or(o2, bit:_lshift(int3, 6))
    local o4 = bit:_or(o3, int4)
    return o4
  end
  
}
function bit:_bnot(op1)
  local r = {}
  do
    do
      for SRD1_6_ = 1, 32 do
        if op1[SRD1_6_] == 1 then
          r[SRD1_6_] = 0
        else
          r[SRD1_6_] = 1
        end
      end
    end
  end
  return r
end

function bit:_not(a)
  local op1 = self:d2b(a)
  local r = self:_bnot(op1)
  return self:b2d(r, true)
end

function bit:charCodeAt(s)
  local pos, int, H, L = 1, 0, 0, 0
  local slen = string.len(s)
  local allByte = {}
  while pos <= slen do
    local tLen = utf8.charbytes(s, pos)
    if tLen >= 1 and tLen <= 4 then
      if tLen == 4 then
        int = switch[4](s, pos)
        H = math.floor((int - 65536) / 1024) + 55296
        L = (int - 65536) % 1024 + 56320
        table.insert(allByte, H)
        table.insert(allByte, L)
      else
        int = switch[tLen](s, pos)
        table.insert(allByte, int)
      end
    end
    pos = pos + tLen
  end
  return allByte
end

function bit:_rshift(a, n)
  local r = 0
  if a < 0 then
    r = 0 - self:_frshift(0 - a, n)
  elseif a >= 0 then
    r = self:_frshift(a, n)
  end
  return r
end

function bit:_frshift(a, n)
  local op1 = self:d2b(a)
  local r = self:d2b(0)
  local left = 32 - n
  if n < 32 and n > 0 then
    do
      for SRD1_9_ = left, 1, -1 do
        r[SRD1_9_ + n] = op1[SRD1_9_]
      end
    end
  end
  return self:b2d(r)
end

function bit:_lshift(a, n)
  local op1 = self:d2b(a)
  local r = self:d2b(0)
  if n < 32 and n > 0 then
    do
      for SRD1_8_ = n, 31 do
        r[SRD1_8_ - n + 1] = op1[SRD1_8_ + 1]
      end
    end
  end
  return self:b2d(r, true)
end

function trim(s)
  return s:match("^%s*(.*)"):match("(.-)%s*$")
end

local json = {}
local kind_of = function(obj)
  if type(obj) ~= "table" then
    return type(obj)
  end
  local i = 1
  do
    do
      for SRD1_5_ in pairs(obj) do
        if obj[i] ~= nil then
          i = i + 1
        else
          return "table"
        end
      end
    end
  end
  if i == 1 then
    do return "table" end
    return
  end
  return "array"
end

local escape_str = function(s)
  local in_char = {
    "\\",
    "\"",
    "/",
    "\b",
    "\f",
    "\n",
    "\r",
    "\t"
  }
  local out_char = {
    "\\",
    "\"",
    "/",
    "b",
    "f",
    "n",
    "r",
    "t"
  }
  do
    do
      for SRD1_6_, SRD1_7_ in ipairs(in_char) do
        s = s:gsub(SRD1_7_, "\\" .. out_char[SRD1_6_])
      end
    end
  end
  return s
end

local skip_delim = function(str, pos, delim, err_if_missing)
  pos = pos + #str:match("^%s*", pos)
  if str:sub(pos, pos) ~= delim then
    if err_if_missing then
      error("Expected " .. delim .. " near position " .. pos)
    end
    return pos, false
  end
  return pos + 1, true
end

local function parse_str_val(str, pos, val)
  val = val or ""
  local early_end_error = "End of input found while parsing string."
  if pos > #str then
    error(early_end_error)
  end
  local c = str:sub(pos, pos)
  if c == "\"" then
    return val, pos + 1
  end
  if c ~= "\\" then
    return parse_str_val(str, pos + 1, val .. c)
  end
  local esc_map = {
    b = "\b",
    f = "\f",
    n = "\n",
    r = "\r",
    t = "\t"
  }
  local nextc = str:sub(pos + 1, pos + 1)
  if not nextc then
    error(early_end_error)
  end
  return parse_str_val(str, pos + 2, val .. (esc_map[nextc] or nextc))
end

local parse_num_val = function(str, pos)
  local num_str = str:match("^-?%d+%.?%d*[eE]?[+-]?%d*", pos)
  local val = tonumber(num_str)
  if not val then
    error("Error parsing number at position " .. pos .. ".")
  end
  return val, pos + #num_str
end

function json.stringify(obj, as_key)
  local s = {}
  local kind = kind_of(obj)
  if kind == "array" then
    if as_key then
      error("Can't encode array as key.")
    end
    s[#s + 1] = "["
    do
      do
        for SRD1_7_, SRD1_8_ in ipairs(obj) do
          if SRD1_7_ > 1 then
            s[#s + 1] = ", "
          end
          s[#s + 1] = json.stringify(SRD1_8_)
        end
      end
    end
    s[#s + 1] = "]"
  elseif kind == "table" then
    if as_key then
      error("Can't encode table as key.")
    end
    s[#s + 1] = "{"
    do
      do
        for SRD1_7_, SRD1_8_ in pairs(obj) do
          if #s > 1 then
            s[#s + 1] = ", "
          end
          s[#s + 1] = json.stringify(SRD1_7_, true)
          s[#s + 1] = ":"
          s[#s + 1] = json.stringify(SRD1_8_)
        end
      end
    end
    s[#s + 1] = "}"
  else
    if kind == "string" then
      do return "\"" .. escape_str(obj) .. "\"" end
      return
    end
    if kind == "number" then
      if as_key then
        return "\"" .. tostring(obj) .. "\""
      end
      do return tostring(obj) end
      return
    end
    if kind == "boolean" then
      do return tostring(obj) end
      return
    end
    if kind == "nil" then
      do return "null" end
      return
    end
    error("Unjsonifiable type: " .. kind .. ".")
  end
  return table.concat(s)
end

json.null = {}
function json.parse(str, pos, end_delim)
  pos = pos or 1
  if pos > #str then
    error("Reached unexpected end of input.")
  end
  local pos = pos + #str:match("^%s*", pos)
  local first = str:sub(pos, pos)
  if first == "{" then
    do
      local obj, key, delim_found = {}, true, true
      pos = pos + 1
      while true do
        key, pos = json.parse(str, pos, "}")
        if key == nil then
          return obj, pos
        end
        if not delim_found then
          error("Comma missing between object items.")
        end
        pos = skip_delim(str, pos, ":", true)
        obj[key], pos = json.parse(str, pos)
        pos, delim_found = skip_delim(str, pos, ",")
      end
    end
    return
  end
  if first == "[" then
    do
      local arr, val, delim_found = {}, true, true
      pos = pos + 1
      while true do
        val, pos = json.parse(str, pos, "]")
        if val == nil then
          return arr, pos
        end
        if not delim_found then
          error("Comma missing between array items.")
        end
        arr[#arr + 1] = val
        pos, delim_found = skip_delim(str, pos, ",")
      end
    end
    return
  end
  if first == "\"" then
    do return parse_str_val(str, pos + 1) end
    return
  end
  if first == "-" or first:match("%d") then
    do return parse_num_val(str, pos) end
    return
  end
  if first == end_delim then
    do return nil, pos + 1 end
    return
  end
  do
    local literals = {
      ["true"] = true,
      ["false"] = false,
      null = json.null
    }
    do
      do
        for SRD1_9_, SRD1_10_ in pairs(literals) do
          local lit_end = pos + #SRD1_9_ - 1
          if str:sub(pos, lit_end) == SRD1_9_ then
            return SRD1_10_, lit_end + 1
          end
        end
      end
    end
    local pos_info_str = "position " .. pos .. ": " .. str:sub(pos, pos + 10)
    error("Invalid json syntax starting at " .. pos_info_str)
  end
end

function enc(data, b)
  return (data:gsub(".", function(x)
    local r, b = "", x:byte()
    do
      do
        for SRD1_6_ = 8, 1, -1 do
          r = r .. (b % 2 ^ SRD1_6_ - b % 2 ^ (SRD1_6_ - 1) > 0 and "1" or "0")
        end
      end
    end
    return r
  end
  ) .. "0000"):gsub("%d%d%d?%d?%d?%d?", function(x)
    if #x < 6 then
      return ""
    end
    local c = 0
    do
      do
        for SRD1_5_ = 1, 6 do
          c = c + (x:sub(SRD1_5_, SRD1_5_) == "1" and 2 ^ (6 - SRD1_5_) or 0)
        end
      end
    end
    return b:sub(c + 1, c + 1)
  end
  ) .. ({
    "",
    "??",
    "?"
  })[#data % 3 + 1]
end

function dec(data, b)
  data = string.gsub(data, "[^" .. b .. "=]", "")
  return (data:gsub(".", function(x)
    if x == "?" then
      return ""
    end
    local r, f = "", b:find(x) - 1
    do
      do
        for SRD1_6_ = 6, 1, -1 do
          r = r .. (f % 2 ^ SRD1_6_ - f % 2 ^ (SRD1_6_ - 1) > 0 and "1" or "0")
        end
      end
    end
    return r
  end
  ):gsub("%d%d%d?%d?%d?%d?%d?%d?", function(x)
    if #x ~= 8 then
      return ""
    end
    local c = 0
    do
      do
        for SRD1_5_ = 1, 8 do
          c = c + (x:sub(SRD1_5_, SRD1_5_) == "1" and 2 ^ (8 - SRD1_5_) or 0)
        end
      end
    end
    return string.char(c)
  end
  ))
end

function xorDecrypt(key, data)
  local preData, result
  preData = ""
  result = ""
  local bit_key = bit:charCodeAt(key)
  do
    local c = 0
    local c2 = 1
    while c < #data and not (c >= #data) do
      preData = preData .. string.char(tonumber(string.sub(data, c2, c + 2), 16))
      c = c + 2
      c2 = c2 + 2
    end
  end
  local bit_data = bit:charCodeAt(preData)
  do
    local a = 0
    local b = 0
    while a < #preData do
      if b >= #key then
        b = 0
      end
      a = a + 1
      b = b + 1
      local xor = bit:_xor(bit_data[a], bit_key[b])
      if xor ~= nil and xor < 256 then
        result = result .. string.char(bit:_xor(bit_data[a], bit_key[b]))
      end
    end
  end
  return result
end

function rwmem(Address, SizeOrBuffer)
  assert(Address ~= nil, "[rwmem]: error, provided address is nil.")
  _rw = {}
  if type(SizeOrBuffer) == "number" then
    _ = ""
    do
      do
        for SRD1_5_ = 1, SizeOrBuffer do
          _rw[SRD1_5_] = {
            address = Address - 1 + SRD1_5_,
            flags = gg.TYPE_BYTE
          }
        end
      end
    end
    do
      do
        for SRD1_5_, SRD1_6_ in ipairs(gg.getValues(_rw)) do
          if SRD1_6_.value == 0 and limit == true then
            return _
          end
          _ = _ .. string.format("%02X", SRD1_6_.value & 255)
        end
      end
    end
    return _
  end
  Byte = {}
  SizeOrBuffer:gsub("..", function(x)
    Byte[#Byte + 1] = x
    _rw[#Byte] = {
      address = Address - 1 + #Byte,
      flags = gg.TYPE_BYTE,
      value = x .. "h"
    }
  end
  )
  gg.setValues(_rw)
end

function hexdecode(hex)
  return (hex:gsub("%x%x", function(digits)
    return string.char(tonumber(digits, 16))
  end
  ))
end

function hexencode(str)
  return (str:gsub(".", function(char)
    return string.format("%2x", char:byte())
  end
  ))
end

function Dec2Hex(nValue)
  nHexVal = string.format("%X", nValue)
  sHexVal = nHexVal .. ""
  return sHexVal
end

function ToInteger(number)
  return math.floor(tonumber(number) or error("Could not cast '" .. tostring(number) .. "' to number.'"))
end

function save(data)
  io.open(gg.EXT_STORAGE .. "/decrypt.txt", "w"):write(data)
  gg.toast("â•”â•â•â•—â”€â”€â”€â”€â”€â”€â”€â”€â”€â•”â•—\nâ•šâ•—â•—â• â•â•¦â•â•¦â•¦â•¦â•¦â•¦â•â•£â•šâ•—\nâ•”â•©â•â•‘â•©â•£â•â•£â•”â•£â•‘â•‘â•¬â•‘â•”â•£\nâ•šâ•â•â•©â•â•©â•â•©â•â• â•—â•‘â•”â•©â•â•\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â•šâ•â•©â•\nâ•”â•â•â•—â”€â”€â”€â”€â”€â”€â”€â•”â•â•¦â•â•—\nâ•‘â•â•â•¬â•¦â•¦â•â•¦â•â•¦â•â•£â•â•£â•â•¬â•¦â•¦â•—â•”â•—\nâ• â•â•â•‘â•‘â•‘â•â•£â•â•£â•©â•¬â•â•‘â•”â•£â•‘â•‘â•šâ•£â•šâ•—\nâ•šâ•â•â•©â•â•©â•â•©â•â•©â•â•©â•â•©â•â•šâ•â•©â•â•©â•â•")
end

function saveEhi(data)
  io.open(gg.EXT_STORAGE .. "/ehi.txt", "w"):write(data)
end

local ehi
local Http = {}
function Http:New(data)
  ehi = data
end


local includes = function(tab, val)
  do
    do
      for SRD1_5_, SRD1_6_ in ipairs(tab) do
        if SRD1_6_ == val then
          return true
        end
      end
    end
  end
  return false
end


function parseTlsTunnel(data)
  local jsonData = json.parse(hexdecode(data))
  Http:New(jsonData)
      message = ""
      message = message .. "ğ„ğ’ğ“ğ„ğğ€ğğ™ğ—ğ— ğƒğ„ğ‚ğ‘ğ˜ğğ“ğğ‘\n"
      message = message .. "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n"
      message = message .. "[*] ServerTLS : " .. ehi.h .. "\n" 
      message = message .. "[*] PortTLS : "  .. ehi.i .. "\n"
      message = message .. "[*] HostSSH : "  .. ehi.y .. "\n"
      message = message .. "[*] PortSSH : "  .. ehi.k .. "\n"
      message = message .. "[*] Username : " .. ehi.f .. "\n"
      message = message .. "[*] Password : " .. ehi.g .. "\n"
      message = message .. "[*] Payload : " .. ehi.n .. "\n"
      message = message .. "[*] PayloadAfterTLS : " .. ehi.r .. "\n"
      message = message .. "[*] Proxy : " .. ehi.t .. "\n"
      message = message .. "[*] ProxyPort : " .. ehi.u .. "\n"
      message = message .. "[*] DomainDNS : " .. ehi.w .. "\n"
      message = message .. "[*] PortDNS : " .. ehi.x .. "\n"
      message = message .. "[*] PublicKey : " .. ehi.z .. "\n"
      message = message .. "[*] ToolsBy : @EstebanZxx\n" 
    gg.copyText(message, true)
    gg.alert(message)
    saveEhi(message)
end

-----------------------------------------------------------------------------------------------------
-- ğ‘ğğ¬ğ©ğğœğ­ ğ‚ğ«ğğšğ­ğ¨ğ«ğ¬. ğƒğ¨ğ§'ğ­ ğ‘ğğ¦ğ¨ğ¯ğ ğ‚ğ«ğğğ¢ğ­ ğŒğ¨ğğ®ğ¥ğğ¬..!!
-- ğ‚ğ¨ğğğ ğğ² : ğ„ğ’ğ“ğ„ğğ€ğ_ğ™ğ—ğ—
-----------------------------------------------------------------------------------------------------

  limit = true
  gg.clearResults()
  gg.setVisible(false)
  gg.setRanges(gg.REGION_JAVA_HEAP)
  gg.setVisible(false)
  gg.processResume()
  gg.searchNumber("h 7b 22 41 22 3a", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1)
  if #r < 1 then
    gg.toast("âš  Metode 1 Gagal")
    hi_method2 = true
  end
  if hi_method2 then
    gg.searchNumber("h 7B 22 63 6F 6E 66 69 67 49 64 65 6E 74 69 66 69 65 72 22 3A", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      return (Menu)
    end
  end
  gg.searchNumber("h7B", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1000)
  readedMem = rwmem(r[1].address, 50000)
  save(hexdecode(readedMem))
  do
    do
      for SRD1_5_, SRD1_6_ in ipairs(r) do
        r[SRD1_5_].flags = gg.TYPE_FLOAT
        r[SRD1_5_].value = "1000"
      end
    end
  end
  gg.setValues(r)
  gg.clearResults()
  parseTlsTunnel(readedMem)
end
-----------------------------------------------------------------------------------------------------
-- ğ‘ğğ¬ğ©ğğœğ­ ğ‚ğ«ğğšğ­ğ¨ğ«ğ¬. ğƒğ¨ğ§'ğ­ ğ‘ğğ¦ğ¨ğ¯ğ ğ‚ğ«ğğğ¢ğ­ ğŒğ¨ğğ®ğ¥ğğ¬..!!
-- ğ‚ğ¨ğğğ ğğ² : ğ„ğ’ğ“ğ„ğğ€ğ_ğ™ğ—ğ—
-----------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------
-- ğ‘ğğ¬ğ©ğğœğ­ ğ‚ğ«ğğšğ­ğ¨ğ«ğ¬. ğƒğ¨ğ§'ğ­ ğ‘ğğ¦ğ¨ğ¯ğ ğ‚ğ«ğğğ¢ğ­ ğŒğ¨ğğ®ğ¥ğğ¬..!!
-- ğ‚ğ¨ğğğ ğğ² : ğ„ğ’ğ“ğ„ğğ€ğ_ğ™ğ—ğ—
-----------------------------------------------------------------------------------------------------

function NapsternetV()
local utf8 = {}
local bit = {
  data32 = {}
}
do
  do
    for SRD1_5_ = 1, 32 do
      bit.data32[SRD1_5_] = 2 ^ (32 - SRD1_5_)
    end
  end
end
local toby = string.byte
function utf8.charbytes(s, i)
  i = i or 1
  local c = string.byte(s, i)
  if c > 0 and c <= 127 then
    do return 1 end
    return
  end
  if c >= 194 and c <= 223 then
    do return 2 end
    return
  end
  if c >= 224 and c <= 239 then
    do return 3 end
    return
  end
  if c >= 240 and c <= 244 then
    return 4
  end
  return 1
end

local ded
function bit:d2b(arg)
  if arg == nil then
    return
  end
  local tr, c = {}, arg < 0
  if c then
    arg = 0 - arg
  end
  do
    do
      for SRD1_7_ = 1, 32 do
        if arg >= self.data32[SRD1_7_] then
          tr[SRD1_7_] = 1
          arg = arg - self.data32[SRD1_7_]
        else
          tr[SRD1_7_] = 0
        end
      end
    end
  end
  if c then
    tr = self:_bnot(tr)
    tr = self:b2d(tr) + 1
    tr = self:d2b(tr)
  end
  return tr
end

function bit:b2d(arg, neg)
  local nr = 0
  if arg[1] == 1 and neg == true then
    arg = self:_bnot(arg)
    nr = self:b2d(arg) + 1
    nr = 0 - nr
  else
    do
      for SRD1_7_ = 1, 32 do
        if arg[SRD1_7_] == 1 then
          nr = nr + 2 ^ (32 - SRD1_7_)
        end
      end
    end
  end
  return nr
end

function bit:_and(a, b)
  local op1 = self:d2b(a)
  local op2 = self:d2b(b)
  local r = {}
  do
    do
      for SRD1_9_ = 1, 32 do
        if op1[SRD1_9_] == 1 and op2[SRD1_9_] == 1 then
          r[SRD1_9_] = 1
        else
          r[SRD1_9_] = 0
        end
      end
    end
  end
  return self:b2d(r, true)
end

function bit:_or(a, b)
  local op1 = self:d2b(a)
  local op2 = self:d2b(b)
  local r = {}
  do
    do
      for SRD1_9_ = 1, 32 do
        if op1[SRD1_9_] == 1 or op2[SRD1_9_] == 1 then
          r[SRD1_9_] = 1
        else
          r[SRD1_9_] = 0
        end
      end
    end
  end
  return self:b2d(r, true)
end

function bit:_xor(a, b)
  local op1 = self:d2b(a)
  if op1 == nil then
    return nil
  end
  local op2 = self:d2b(b)
  if op2 == nil then
    return nil
  end
  local r = {}
  do
    do
      for SRD1_9_ = 1, 32 do
        if op1[SRD1_9_] == op2[SRD1_9_] then
          r[SRD1_9_] = 0
        else
          r[SRD1_9_] = 1
        end
      end
    end
  end
  return self:b2d(r, true)
end

local switch = {
  [1] = function(s, pos)
    local c1 = toby(s, pos)
    return c1
  end
  ,
  [2] = function(s, pos)
    local c1 = toby(s, pos)
    local c2 = toby(s, pos + 1)
    local int1 = bit:_and(31, c1)
    local int2 = bit:_and(63, c2)
    return bit:_or(bit:_lshift(int1, 6), int2)
  end
  ,
  [3] = function(s, pos)
    local c1 = toby(s, pos)
    local c2 = toby(s, pos + 1)
    local c3 = toby(s, pos + 2)
    local int1 = bit:_and(15, c1)
    local int2 = bit:_and(63, c2)
    local int3 = bit:_and(63, c3)
    local o2 = bit:_or(bit:_lshift(int1, 12), bit:_lshift(int2, 6))
    local dt = bit:_or(o2, int3)
    return dt
  end
  ,
  [4] = function(s, pos)
    local c1 = toby(s, pos)
    local c2 = toby(s, pos + 1)
    local c3 = toby(s, pos + 2)
    local c4 = toby(s, pos + 3)
    local int1 = bit:_and(15, c1)
    local int2 = bit:_and(63, c2)
    local int3 = bit:_and(63, c3)
    local int4 = bit:_and(63, c4)
    local o2 = bit:_or(bit:_lshift(int1, 18), bit:_lshift(int2, 12))
    local o3 = bit:_or(o2, bit:_lshift(int3, 6))
    local o4 = bit:_or(o3, int4)
    return o4
  end
  
}
function bit:_bnot(op1)
  local r = {}
  do
    do
      for SRD1_6_ = 1, 32 do
        if op1[SRD1_6_] == 1 then
          r[SRD1_6_] = 0
        else
          r[SRD1_6_] = 1
        end
      end
    end
  end
  return r
end

function bit:_not(a)
  local op1 = self:d2b(a)
  local r = self:_bnot(op1)
  return self:b2d(r, true)
end

function bit:charCodeAt(s)
  local pos, int, H, L = 1, 0, 0, 0
  local slen = string.len(s)
  local allByte = {}
  while pos <= slen do
    local tLen = utf8.charbytes(s, pos)
    if tLen >= 1 and tLen <= 4 then
      if tLen == 4 then
        int = switch[4](s, pos)
        H = math.floor((int - 65536) / 1024) + 55296
        L = (int - 65536) % 1024 + 56320
        table.insert(allByte, H)
        table.insert(allByte, L)
      else
        int = switch[tLen](s, pos)
        table.insert(allByte, int)
      end
    end
    pos = pos + tLen
  end
  return allByte
end

function bit:_rshift(a, n)
  local r = 0
  if a < 0 then
    r = 0 - self:_frshift(0 - a, n)
  elseif a >= 0 then
    r = self:_frshift(a, n)
  end
  return r
end

function bit:_frshift(a, n)
  local op1 = self:d2b(a)
  local r = self:d2b(0)
  local left = 32 - n
  if n < 32 and n > 0 then
    do
      for SRD1_9_ = left, 1, -1 do
        r[SRD1_9_ + n] = op1[SRD1_9_]
      end
    end
  end
  return self:b2d(r)
end

function bit:_lshift(a, n)
  local op1 = self:d2b(a)
  local r = self:d2b(0)
  if n < 32 and n > 0 then
    do
      for SRD1_8_ = n, 31 do
        r[SRD1_8_ - n + 1] = op1[SRD1_8_ + 1]
      end
    end
  end
  return self:b2d(r, true)
end

function trim(s)
  return s:match("^%s*(.*)"):match("(.-)%s*$")
end

local json = {}
local kind_of = function(obj)
  if type(obj) ~= "table" then
    return type(obj)
  end
  local i = 1
  do
    do
      for SRD1_5_ in pairs(obj) do
        if obj[i] ~= nil then
          i = i + 1
        else
          return "table"
        end
      end
    end
  end
  if i == 1 then
    do return "table" end
    return
  end
  return "array"
end

local escape_str = function(s)
  local in_char = {
    "\\",
    "\"",
    "/",
    "\b",
    "\f",
    "\n",
    "\r",
    "\t"
  }
  local out_char = {
    "\\",
    "\"",
    "/",
    "b",
    "f",
    "n",
    "r",
    "t"
  }
  do
    do
      for SRD1_6_, SRD1_7_ in ipairs(in_char) do
        s = s:gsub(SRD1_7_, "\\" .. out_char[SRD1_6_])
      end
    end
  end
  return s
end

local skip_delim = function(str, pos, delim, err_if_missing)
  pos = pos + #str:match("^%s*", pos)
  if str:sub(pos, pos) ~= delim then
    if err_if_missing then
      error("Expected " .. delim .. " near position " .. pos)
    end
    return pos, false
  end
  return pos + 1, true
end

local function parse_str_val(str, pos, val)
  val = val or ""
  local early_end_error = "End of input found while parsing string."
  if pos > #str then
    error(early_end_error)
  end
  local c = str:sub(pos, pos)
  if c == "\"" then
    return val, pos + 1
  end
  if c ~= "\\" then
    return parse_str_val(str, pos + 1, val .. c)
  end
  local esc_map = {
    b = "\b",
    f = "\f",
    n = "\n",
    r = "\r",
    t = "\t"
  }
  local nextc = str:sub(pos + 1, pos + 1)
  if not nextc then
    error(early_end_error)
  end
  return parse_str_val(str, pos + 2, val .. (esc_map[nextc] or nextc))
end

local parse_num_val = function(str, pos)
  local num_str = str:match("^-?%d+%.?%d*[eE]?[+-]?%d*", pos)
  local val = tonumber(num_str)
  if not val then
    error("Error parsing number at position " .. pos .. ".")
  end
  return val, pos + #num_str
end

function json.stringify(obj, as_key)
  local s = {}
  local kind = kind_of(obj)
  if kind == "array" then
    if as_key then
      error("Can't encode array as key.")
    end
    s[#s + 1] = "["
    do
      do
        for SRD1_7_, SRD1_8_ in ipairs(obj) do
          if SRD1_7_ > 1 then
            s[#s + 1] = ", "
          end
          s[#s + 1] = json.stringify(SRD1_8_)
        end
      end
    end
    s[#s + 1] = "]"
  elseif kind == "table" then
    if as_key then
      error("Can't encode table as key.")
    end
    s[#s + 1] = "{"
    do
      do
        for SRD1_7_, SRD1_8_ in pairs(obj) do
          if #s > 1 then
            s[#s + 1] = ", "
          end
          s[#s + 1] = json.stringify(SRD1_7_, true)
          s[#s + 1] = ":"
          s[#s + 1] = json.stringify(SRD1_8_)
        end
      end
    end
    s[#s + 1] = "}"
  else
    if kind == "string" then
      do return "\"" .. escape_str(obj) .. "\"" end
      return
    end
    if kind == "number" then
      if as_key then
        return "\"" .. tostring(obj) .. "\""
      end
      do return tostring(obj) end
      return
    end
    if kind == "boolean" then
      do return tostring(obj) end
      return
    end
    if kind == "nil" then
      do return "null" end
      return
    end
    error("Unjsonifiable type: " .. kind .. ".")
  end
  return table.concat(s)
end

json.null = {}
function json.parse(str, pos, end_delim)
  pos = pos or 1
  if pos > #str then
    error("Reached unexpected end of input.")
  end
  local pos = pos + #str:match("^%s*", pos)
  local first = str:sub(pos, pos)
  if first == "{" then
    do
      local obj, key, delim_found = {}, true, true
      pos = pos + 1
      while true do
        key, pos = json.parse(str, pos, "}")
        if key == nil then
          return obj, pos
        end
        if not delim_found then
          error("Comma missing between object items.")
        end
        pos = skip_delim(str, pos, ":", true)
        obj[key], pos = json.parse(str, pos)
        pos, delim_found = skip_delim(str, pos, ",")
      end
    end
    return
  end
  if first == "[" then
    do
      local arr, val, delim_found = {}, true, true
      pos = pos + 1
      while true do
        val, pos = json.parse(str, pos, "]")
        if val == nil then
          return arr, pos
        end
        if not delim_found then
          error("Comma missing between array items.")
        end
        arr[#arr + 1] = val
        pos, delim_found = skip_delim(str, pos, ",")
      end
    end
    return
  end
  if first == "\"" then
    do return parse_str_val(str, pos + 1) end
    return
  end
  if first == "-" or first:match("%d") then
    do return parse_num_val(str, pos) end
    return
  end
  if first == end_delim then
    do return nil, pos + 1 end
    return
  end
  do
    local literals = {
      ["true"] = true,
      ["false"] = false,
      null = json.null
    }
    do
      do
        for SRD1_9_, SRD1_10_ in pairs(literals) do
          local lit_end = pos + #SRD1_9_ - 1
          if str:sub(pos, lit_end) == SRD1_9_ then
            return SRD1_10_, lit_end + 1
          end
        end
      end
    end
    local pos_info_str = "position " .. pos .. ": " .. str:sub(pos, pos + 10)
    error("Invalid json syntax starting at " .. pos_info_str)
  end
end

function enc(data, b)
  return (data:gsub(".", function(x)
    local r, b = "", x:byte()
    do
      do
        for SRD1_6_ = 8, 1, -1 do
          r = r .. (b % 2 ^ SRD1_6_ - b % 2 ^ (SRD1_6_ - 1) > 0 and "1" or "0")
        end
      end
    end
    return r
  end
  ) .. "0000"):gsub("%d%d%d?%d?%d?%d?", function(x)
    if #x < 6 then
      return ""
    end
    local c = 0
    do
      do
        for SRD1_5_ = 1, 6 do
          c = c + (x:sub(SRD1_5_, SRD1_5_) == "1" and 2 ^ (6 - SRD1_5_) or 0)
        end
      end
    end
    return b:sub(c + 1, c + 1)
  end
  ) .. ({
    "",
    "??",
    "?"
  })[#data % 3 + 1]
end

function dec(data, b)
  data = string.gsub(data, "[^" .. b .. "=]", "")
  return (data:gsub(".", function(x)
    if x == "?" then
      return ""
    end
    local r, f = "", b:find(x) - 1
    do
      do
        for SRD1_6_ = 6, 1, -1 do
          r = r .. (f % 2 ^ SRD1_6_ - f % 2 ^ (SRD1_6_ - 1) > 0 and "1" or "0")
        end
      end
    end
    return r
  end
  ):gsub("%d%d%d?%d?%d?%d?%d?%d?", function(x)
    if #x ~= 8 then
      return ""
    end
    local c = 0
    do
      do
        for SRD1_5_ = 1, 8 do
          c = c + (x:sub(SRD1_5_, SRD1_5_) == "1" and 2 ^ (8 - SRD1_5_) or 0)
        end
      end
    end
    return string.char(c)
  end
  ))
end

function xorDecrypt(key, data)
  local preData, result
  preData = ""
  result = ""
  local bit_key = bit:charCodeAt(key)
  do
    local c = 0
    local c2 = 1
    while c < #data and not (c >= #data) do
      preData = preData .. string.char(tonumber(string.sub(data, c2, c + 2), 16))
      c = c + 2
      c2 = c2 + 2
    end
  end
  local bit_data = bit:charCodeAt(preData)
  do
    local a = 0
    local b = 0
    while a < #preData do
      if b >= #key then
        b = 0
      end
      a = a + 1
      b = b + 1
      local xor = bit:_xor(bit_data[a], bit_key[b])
      if xor ~= nil and xor < 256 then
        result = result .. string.char(bit:_xor(bit_data[a], bit_key[b]))
      end
    end
  end
  return result
end

function rwmem(Address, SizeOrBuffer)
  assert(Address ~= nil, "[rwmem]: error, provided address is nil.")
  _rw = {}
  if type(SizeOrBuffer) == "number" then
    _ = ""
    do
      do
        for SRD1_5_ = 1, SizeOrBuffer do
          _rw[SRD1_5_] = {
            address = Address - 1 + SRD1_5_,
            flags = gg.TYPE_BYTE
          }
        end
      end
    end
    do
      do
        for SRD1_5_, SRD1_6_ in ipairs(gg.getValues(_rw)) do
          if SRD1_6_.value == 0 and limit == true then
            return _
          end
          _ = _ .. string.format("%02X", SRD1_6_.value & 255)
        end
      end
    end
    return _
  end
  Byte = {}
  SizeOrBuffer:gsub("..", function(x)
    Byte[#Byte + 1] = x
    _rw[#Byte] = {
      address = Address - 1 + #Byte,
      flags = gg.TYPE_BYTE,
      value = x .. "h"
    }
  end
  )
  gg.setValues(_rw)
end

function hexdecode(hex)
  return (hex:gsub("%x%x", function(digits)
    return string.char(tonumber(digits, 16))
  end
  ))
end

function hexencode(str)
  return (str:gsub(".", function(char)
    return string.format("%2x", char:byte())
  end
  ))
end

function Dec2Hex(nValue)
  nHexVal = string.format("%X", nValue)
  sHexVal = nHexVal .. ""
  return sHexVal
end

function ToInteger(number)
  return math.floor(tonumber(number) or error("Could not cast '" .. tostring(number) .. "' to number.'"))
end

function save(data)
  io.open(gg.EXT_STORAGE .. "/decrypt.txt", "w"):write(data)
  gg.toast("â•”â•â•â•—â”€â”€â”€â”€â”€â”€â”€â”€â”€â•”â•—\nâ•šâ•—â•—â• â•â•¦â•â•¦â•¦â•¦â•¦â•¦â•â•£â•šâ•—\nâ•”â•©â•â•‘â•©â•£â•â•£â•”â•£â•‘â•‘â•¬â•‘â•”â•£\nâ•šâ•â•â•©â•â•©â•â•©â•â• â•—â•‘â•”â•©â•â•\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â•šâ•â•©â•\nâ•”â•â•â•—â”€â”€â”€â”€â”€â”€â”€â•”â•â•¦â•â•—\nâ•‘â•â•â•¬â•¦â•¦â•â•¦â•â•¦â•â•£â•â•£â•â•¬â•¦â•¦â•—â•”â•—\nâ• â•â•â•‘â•‘â•‘â•â•£â•â•£â•©â•¬â•â•‘â•”â•£â•‘â•‘â•šâ•£â•šâ•—\nâ•šâ•â•â•©â•â•©â•â•©â•â•©â•â•©â•â•©â•â•šâ•â•©â•â•©â•â•")
end

function saveEhi(data)
  io.open(gg.EXT_STORAGE .. "/Zxx_NPV4.txt", "w"):write(data)
end

local ehi
local Http = {}
function Http:New(data)
  ehi = data
end


local includes = function(tab, val)
  do
    do
      for SRD1_5_, SRD1_6_ in ipairs(tab) do
        if SRD1_6_ == val then
          return true
        end
      end
    end
  end
  return false
end

-----------------------------------------------------------------------------------------------------
-- ğ‘ğğ¬ğ©ğğœğ­ ğ‚ğ«ğğšğ­ğ¨ğ«ğ¬. ğƒğ¨ğ§'ğ­ ğ‘ğğ¦ğ¨ğ¯ğ ğ‚ğ«ğğğ¢ğ­ ğŒğ¨ğğ®ğ¥ğğ¬..!!
-- ğ‚ğ¨ğğğ ğğ² : ğ„ğ’ğ“ğ„ğğ€ğ_ğ™ğ—ğ—
-----------------------------------------------------------------------------------------------------

  limit = true
  gg.clearResults()
  gg.setVisible(false)
  gg.setRanges(gg.REGION_JAVA_HEAP)
  gg.setVisible(false)
  gg.processResume()
  gg.searchNumber("h 7b 22 76 65 72 73 69 6f 6e 69 6e 67", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1)
  if #r < 1 then
    gg.toast("âš  Metode 1 Gagal")
    hi_method2 = true
  end
  if hi_method2 then
    gg.searchNumber("h 7B 22 63 6F 6E 66 69 67 49 64 65 6E 74 69 66 69 65 72 22 3A", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      return (Menu)
    end
  end
  gg.searchNumber("h7B", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1000)
  readedMem = rwmem(r[1].address, 50000)
  save(hexdecode(readedMem))
  do
    do
      for SRD1_5_, SRD1_6_ in ipairs(r) do
        r[SRD1_5_].flags = gg.TYPE_FLOAT
        r[SRD1_5_].value = "1000"
      end
    end
  end
  gg.setValues(r)
  gg.clearResults()
end
-----------------------------------------------------------------------------------------------------
-- ğ‘ğğ¬ğ©ğğœğ­ ğ‚ğ«ğğšğ­ğ¨ğ«ğ¬. ğƒğ¨ğ§'ğ­ ğ‘ğğ¦ğ¨ğ¯ğ ğ‚ğ«ğğğ¢ğ­ ğŒğ¨ğğ®ğ¥ğğ¬..!!
-- ğ‚ğ¨ğğğ ğğ² : ğ„ğ’ğ“ğ„ğğ€ğ_ğ™ğ—ğ—
-----------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------
-- ğ‘ğğ¬ğ©ğğœğ­ ğ‚ğ«ğğšğ­ğ¨ğ«ğ¬. ğƒğ¨ğ§'ğ­ ğ‘ğğ¦ğ¨ğ¯ğ ğ‚ğ«ğğğ¢ğ­ ğŒğ¨ğğ®ğ¥ğğ¬..!!
-- ğ‚ğ¨ğğğ ğğ² : ğ„ğ’ğ“ğ„ğğ€ğ_ğ™ğ—ğ—
-----------------------------------------------------------------------------------------------------

function ResultNapsternetV()
local open = io.open
local function read_file(path)
    local file = open(path, "rb")
    if not file then return nil end
    local content = file:read "*a"
    file:close()
    return content
end
local fileContent = read_file("/sdcard/decrypt.txt");
--gg.alert("ğ„ğ’ğ“ğ„ğğ€ğğ™ğ—ğ— ğƒğ„ğ‚ğ‘ğ˜ğğ“ğğ‘\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n[*] DataConfig : " .. fileContent .. "\n[*] ToolsBy : @EstebanZxx");
--gg.copyText("ğ„ğ’ğ“ğ„ğğ€ğğ™ğ—ğ— ğƒğ„ğ‚ğ‘ğ˜ğğ“ğğ‘\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n[*] DataConfig : " .. fileContent .. "\n[*] ToolsBy : @EstebanZxx", true)
print("ğ„ğ’ğ“ğ„ğğ€ğğ™ğ—ğ— ğƒğ„ğ‚ğ‘ğ˜ğğ“ğğ‘\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n[*] DataConfig : " .. fileContent .. "\n[*] ToolsBy : @EstebanZxx");
gg.skipRestoreState()
gg.setVisible(true)
os.exit()
end

-----------------------------------------------------------------------------------------------------
-- ğ‘ğğ¬ğ©ğğœğ­ ğ‚ğ«ğğšğ­ğ¨ğ«ğ¬. ğƒğ¨ğ§'ğ­ ğ‘ğğ¦ğ¨ğ¯ğ ğ‚ğ«ğğğ¢ğ­ ğŒğ¨ğğ®ğ¥ğğ¬..!!
-- ğ‚ğ¨ğğğ ğğ² : ğ„ğ’ğ“ğ„ğğ€ğ_ğ™ğ—ğ—
-----------------------------------------------------------------------------------------------------

function DarkTunnel()
function save(data)
    io.open(gg.EXT_STORAGE .. "/decrypt.txt", "w"):write(hexdecode(data))
    gg.toast("âœ“ ğƒğğœğ«ğ²ğ©ğ­ ğ’ğ®ğœğœğğ¬ğ¬ğŸğ®ğ¥")
    gg.alert("â•”â•â•â•—â”€â”€â”€â”€â”€â”€â”€â”€â”€â•”â•—\nâ•šâ•—â•—â• â•â•¦â•â•¦â•¦â•¦â•¦â•¦â•â•£â•šâ•—\nâ•”â•©â•â•‘â•©â•£â•â•£â•”â•£â•‘â•‘â•¬â•‘â•”â•£\nâ•šâ•â•â•©â•â•©â•â•©â•â• â•—â•‘â•”â•©â•â•\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â•šâ•â•©â•\nâ•”â•â•â•—â”€â”€â”€â”€â”€â”€â”€â•”â•â•¦â•â•—\nâ•‘â•â•â•¬â•¦â•¦â•â•¦â•â•¦â•â•£â•â•£â•â•¬â•¦â•¦â•—â•”â•—\nâ• â•â•â•‘â•‘â•‘â•â•£â•â•£â•©â•¬â•â•‘â•”â•£â•‘â•‘â•šâ•£â•šâ•—\nâ•šâ•â•â•©â•â•©â•â•©â•â•©â•â•©â•â•©â•â•šâ•â•©â•â•©â•â•", "ğ˜½ğ™–ğ™˜ğ™  ğ™ˆğ™šğ™£ğ™ª")
    end
  gg.clearResults()
  gg.setRanges(gg.REGION_ANONYMOUS)
  gg.setVisible(true)
  gg.searchNumber("h537368436F6E6669674C6F636B6564C3A9537368436F6E666967", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1)
     if #r < 1 then
    gg.toast("âœ˜ ğŒğğ­ğ¡ğ¨ğ ğŸ ğ…ğšğ¢ğ¥ğğ")
    dark_2 = true
    end
    if dark_2 then
    gg.searchNumber("h53 73 68 43 6f 6e 66 69 67 4c 6f 63 6b 65 64 e9 53 73 68 43 6f 6e 66 69 67", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("âœ˜ ğŒğğ­ğ¡ğ¨ğ ğŸ ğ…ğšğ¢ğ¥ğğ")
      dark_3 = true
      end
      end
    if dark_3 then
    gg.searchNumber("h53 73 68 43 6f 6e 66 69 67 4c 6f 63 6b 65 64", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("âœ˜ ğŒğğ­ğ¡ğ¨ğ ğŸ‘ ğ…ğšğ¢ğ¥ğğ")
      dark_4 = true
      end
      end
    if dark_4 then
    gg.toast("âœ˜ ğƒğğœğ«ğ²ğ©ğ­ ğ…ğšğ¢ğ¥ğğ")
    return (Menu)
    end
  local r = gg.getResults(1000)
  if limit == false then
    r[1].address = r[1].address - 0x2000
  end
  readedMem = rwmem(r[1].address, 10000)
  save(readedMem)
  gg.clearResults()
end

-----------------------------------------------------------------------------------------------------
-- ğ‘ğğ¬ğ©ğğœğ­ ğ‚ğ«ğğšğ­ğ¨ğ«ğ¬. ğƒğ¨ğ§'ğ­ ğ‘ğğ¦ğ¨ğ¯ğ ğ‚ğ«ğğğ¢ğ­ ğŒğ¨ğğ®ğ¥ğğ¬..!!
-- ğ‚ğ¨ğğğ ğğ² : ğ„ğ’ğ“ğ„ğğ€ğ_ğ™ğ—ğ—
-----------------------------------------------------------------------------------------------------

function CreditModules()
  gg.alert("ğ™²ğš˜ğš™ğš¢ğš›ğš’ğšğš‘ğš (ğ™²) ğŸ¸0ğŸ¸ğŸ¹ ğ™´ğšœğšğšğš‹ğšŠğš—ğšƒğ™¾ğ™¾ğ™»ğš‚\nğš—ğšƒğš‘ğš’ğšœ ğš‚ğšŒğš›ğš’ğš™ğš ğ™²ğš›ğšğšŠğšğšğš ğ™°ğš—ğš ğ™´ğšğš’ğšğšğš ğ™±ğš¢ ğš‘ğšğšğš™ğšœ://ğš.ğš–ğš/ğ™´ğšœğšğšğš‹ğšŠğš—ğš‰ğš¡ğš¡ @ğ™ºğš–ğš”ğš£ğš£ğš£ @ğš—ğš˜ğšğš¢ğš˜ğšğš›ğšœ_ğŸ¹ğŸ¸ğŸ·, ğšƒğš‘ğš’ğšœ ğš‚ğšŒğš›ğš’ğš™ğš ğ™¸ğšœ ğ™´ğš—ğšŒğš›ğš¢ğš™ğšğšğš ğ™°ğš—ğš ğ™½ğš˜ğš ğ™µğš˜ğš› ğšğš-ğ™´ğšğš’ğšğš’ğš—ğš.\nğ™°ğšœ ğš ğš ğš”ğš—ğš˜ğš , ğš¢ğš˜ğš'ğš›ğš ğš˜ğš—ğš•ğš¢ ğšğšğš’ğšğš’ğš—ğš ğš™ğšŠğš›ğš ğš˜ğš ğšğš‘ğš ğš–ğšğšœğšœğšŠğšğš ğšğšğš–ğš™ğš•ğšŠğšğš, ğšŠğš—ğš ğš’ğš ğšğš˜ğšğšœğš—'ğš ğš‘ğšğš•ğš™ ğšğš‘ğš ğšğšğšŸğšğš•ğš˜ğš™ğš–ğšğš—ğš ğš˜ğš ğšğš‘ğš’ğšœ ğšœğšŒğš›ğš’ğš™ğš ğšŠğš ğšŠğš•ğš•\nğšƒğš‘ğš’ğšœ ğš™ğš›ğš˜ğšğš›ğšŠğš– ğš ğš’ğš•ğš• ğšŒğš˜ğš—ğšğš’ğš—ğšğš ğšğš˜ ğš›ğšğš— ğšŠğšœ ğš•ğš˜ğš—ğš ğšŠğšœ ğšğš‘ğš ğšŒğš›ğšğšŠğšğš˜ğš›ğšœ ğšŠğš—ğš ğšğšğš’ğšğš˜ğš›ğšœ ğšŠğš›ğš ğšŠğš•ğš’ğšŸğš,\nğš¢ğš˜ğš ğšŒğšŠğš— ğš–ğš˜ğš—ğš’ğšğš˜ğš› ğšğš‘ğšğš’ğš› ğš™ğš›ğš˜ğšğš›ğšğšœğšœ ğš˜ğš— ğšğš‘ğš ğšƒğšğš•ğšğšğš›ğšŠğš– ğ™²ğš‘ğšŠğš—ğš—ğšğš• / ğ™¶ğš›ğš˜ğšğš™ : ğŠğŒğŠğ™ ğŸğŸğŸ ğ– ™ á¯“", "ğ˜½ğ™–ğ™˜ğ™  ğ™ˆğ™šğ™£ğ™ª")
gg.skipRestoreState()
gg.setVisible(true)
return (Menu)
end

-----------------------------------------------------------------------------------------------------
-- ğ‘ğğ¬ğ©ğğœğ­ ğ‚ğ«ğğšğ­ğ¨ğ«ğ¬. ğƒğ¨ğ§'ğ­ ğ‘ğğ¦ğ¨ğ¯ğ ğ‚ğ«ğğğ¢ğ­ ğŒğ¨ğğ®ğ¥ğğ¬..!!
-- ğ‚ğ¨ğğğ ğğ² : ğ„ğ’ğ“ğ„ğğ€ğ_ğ™ğ—ğ—
-----------------------------------------------------------------------------------------------------

function ExitScript()
print(" ")
print("â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—â–‘â–‘â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—â–‘â–‘â–ˆâ–ˆâ•—")
print("â•šâ•â•â•â•â–ˆâ–ˆâ•‘  â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•  â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•")
print("â–‘â–‘â–ˆâ–ˆâ–ˆâ•”â•â•  â–‘â•šâ–ˆâ–ˆâ–ˆâ•”â•â–‘  â–‘â•šâ–ˆâ–ˆâ–ˆâ•”â•â–‘")
print("â–ˆâ–ˆâ•”â•â•â•â–‘â–‘  â–‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•—â–‘  â–‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•—â–‘")
print("â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ•—")
print("â•šâ•â•â•â•â•â•â•  â•šâ•â•â–‘â–‘â•šâ•â•  â•šâ•â•â–‘â–‘â•šâ•â•")
print(" ")
print("                  â–ˆâ–ˆâ•—â–‘â–‘â–ˆâ–ˆâ•—")
print("                  â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•")
print("                  â–‘â•šâ–ˆâ–ˆâ–ˆâ•”â•â–‘")
print("                  â–‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•—â–‘")
print("                  â–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ•—")
print("                  â•šâ•â•â–‘â–‘â•šâ•â•")
print(" ")
print("â–ˆâ–ˆâ•—â–‘â–‘â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—â–‘â–‘â–‘â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—â–‘â–‘â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—")
print("â–ˆâ–ˆâ•‘â–‘â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ•—â–‘â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–‘â–ˆâ–ˆâ•”â•â•šâ•â•â•â•â–ˆâ–ˆâ•‘")
print("â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•â•â–‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•â•â–‘â–‘â–‘â–ˆâ–ˆâ–ˆâ•”â•â•")
print("â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•—â–‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•—â–‘â–ˆâ–ˆâ•”â•â•â•â–‘â–‘")
print("â–ˆâ–ˆâ•‘â–‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–‘â•šâ•â•â–‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—")
print("â•šâ•â•â–‘â–‘â•šâ•â•â•šâ•â•â–‘â–‘â–‘â–‘â–‘â•šâ•â•â•šâ•â•â–‘â–‘â•šâ•â•â•šâ•â•â•â•â•â•â•")
print("-----------------------------------------------------------------------------------------------------")
print("êœ±á´„Ê€Éªá´˜á´› á´á´á´…á´…á´‡Ê€ Ê™Ê : ğ„ğ’ğ“ğ„ğğ€ğ_ğ™ğ—ğ— - ğŠğŒğŠğ™ ğŸğŸğŸ ğ– ™ á¯“")
print("-----------------------------------------------------------------------------------------------------")
gg.skipRestoreState()
gg.setVisible(true)
os.exit()
end

-----------------------------------------------------------------------------------------------------
-- ğ‘ğğ¬ğ©ğğœğ­ ğ‚ğ«ğğšğ­ğ¨ğ«ğ¬. ğƒğ¨ğ§'ğ­ ğ‘ğğ¦ğ¨ğ¯ğ ğ‚ğ«ğğğ¢ğ­ ğŒğ¨ğğ®ğ¥ğğ¬..!!
-- ğ‚ğ¨ğğğ ğğ² : ğ„ğ’ğ“ğ„ğğ€ğ_ğ™ğ—ğ—
-----------------------------------------------------------------------------------------------------

local utf8 = {}
local bit = {
  data32 = {}
}
do
  do
    for SRD1_5_ = 1, 32 do
      bit.data32[SRD1_5_] = 2 ^ (32 - SRD1_5_)
    end
  end
end
local toby = string.byte
function utf8.charbytes(s, i)
  i = i or 1
  local c = string.byte(s, i)
  if c > 0 and c <= 127 then
    do return 1 end
    return
  end
  if c >= 194 and c <= 223 then
    do return 2 end
    return
  end
  if c >= 224 and c <= 239 then
    do return 3 end
    return
  end
  if c >= 240 and c <= 244 then
    return 4
  end
  return 1
end

local ded
function bit:d2b(arg)
  if arg == nil then
    return
  end
  local tr, c = {}, arg < 0
  if c then
    arg = 0 - arg
  end
  do
    do
      for SRD1_7_ = 1, 32 do
        if arg >= self.data32[SRD1_7_] then
          tr[SRD1_7_] = 1
          arg = arg - self.data32[SRD1_7_]
        else
          tr[SRD1_7_] = 0
        end
      end
    end
  end
  if c then
    tr = self:_bnot(tr)
    tr = self:b2d(tr) + 1
    tr = self:d2b(tr)
  end
  return tr
end

function bit:b2d(arg, neg)
  local nr = 0
  if arg[1] == 1 and neg == true then
    arg = self:_bnot(arg)
    nr = self:b2d(arg) + 1
    nr = 0 - nr
  else
    do
      for SRD1_7_ = 1, 32 do
        if arg[SRD1_7_] == 1 then
          nr = nr + 2 ^ (32 - SRD1_7_)
        end
      end
    end
  end
  return nr
end

function bit:_and(a, b)
  local op1 = self:d2b(a)
  local op2 = self:d2b(b)
  local r = {}
  do
    do
      for SRD1_9_ = 1, 32 do
        if op1[SRD1_9_] == 1 and op2[SRD1_9_] == 1 then
          r[SRD1_9_] = 1
        else
          r[SRD1_9_] = 0
        end
      end
    end
  end
  return self:b2d(r, true)
end

function bit:_or(a, b)
  local op1 = self:d2b(a)
  local op2 = self:d2b(b)
  local r = {}
  do
    do
      for SRD1_9_ = 1, 32 do
        if op1[SRD1_9_] == 1 or op2[SRD1_9_] == 1 then
          r[SRD1_9_] = 1
        else
          r[SRD1_9_] = 0
        end
      end
    end
  end
  return self:b2d(r, true)
end

function bit:_xor(a, b)
  local op1 = self:d2b(a)
  if op1 == nil then
    return nil
  end
  local op2 = self:d2b(b)
  if op2 == nil then
    return nil
  end
  local r = {}
  do
    do
      for SRD1_9_ = 1, 32 do
        if op1[SRD1_9_] == op2[SRD1_9_] then
          r[SRD1_9_] = 0
        else
          r[SRD1_9_] = 1
        end
      end
    end
  end
  return self:b2d(r, true)
end

local switch = {
  [1] = function(s, pos)
    local c1 = toby(s, pos)
    return c1
  end
  ,
  [2] = function(s, pos)
    local c1 = toby(s, pos)
    local c2 = toby(s, pos + 1)
    local int1 = bit:_and(31, c1)
    local int2 = bit:_and(63, c2)
    return bit:_or(bit:_lshift(int1, 6), int2)
  end
  ,
  [3] = function(s, pos)
    local c1 = toby(s, pos)
    local c2 = toby(s, pos + 1)
    local c3 = toby(s, pos + 2)
    local int1 = bit:_and(15, c1)
    local int2 = bit:_and(63, c2)
    local int3 = bit:_and(63, c3)
    local o2 = bit:_or(bit:_lshift(int1, 12), bit:_lshift(int2, 6))
    local dt = bit:_or(o2, int3)
    return dt
  end
  ,
  [4] = function(s, pos)
    local c1 = toby(s, pos)
    local c2 = toby(s, pos + 1)
    local c3 = toby(s, pos + 2)
    local c4 = toby(s, pos + 3)
    local int1 = bit:_and(15, c1)
    local int2 = bit:_and(63, c2)
    local int3 = bit:_and(63, c3)
    local int4 = bit:_and(63, c4)
    local o2 = bit:_or(bit:_lshift(int1, 18), bit:_lshift(int2, 12))
    local o3 = bit:_or(o2, bit:_lshift(int3, 6))
    local o4 = bit:_or(o3, int4)
    return o4
  end
  
}
function bit:_bnot(op1)
  local r = {}
  do
    do
      for SRD1_6_ = 1, 32 do
        if op1[SRD1_6_] == 1 then
          r[SRD1_6_] = 0
        else
          r[SRD1_6_] = 1
        end
      end
    end
  end
  return r
end

function bit:_not(a)
  local op1 = self:d2b(a)
  local r = self:_bnot(op1)
  return self:b2d(r, true)
end

function bit:charCodeAt(s)
  local pos, int, H, L = 1, 0, 0, 0
  local slen = string.len(s)
  local allByte = {}
  while pos <= slen do
    local tLen = utf8.charbytes(s, pos)
    if tLen >= 1 and tLen <= 4 then
      if tLen == 4 then
        int = switch[4](s, pos)
        H = math.floor((int - 65536) / 1024) + 55296
        L = (int - 65536) % 1024 + 56320
        table.insert(allByte, H)
        table.insert(allByte, L)
      else
        int = switch[tLen](s, pos)
        table.insert(allByte, int)
      end
    end
    pos = pos + tLen
  end
  return allByte
end

function bit:_rshift(a, n)
  local r = 0
  if a < 0 then
    r = 0 - self:_frshift(0 - a, n)
  elseif a >= 0 then
    r = self:_frshift(a, n)
  end
  return r
end

function bit:_frshift(a, n)
  local op1 = self:d2b(a)
  local r = self:d2b(0)
  local left = 32 - n
  if n < 32 and n > 0 then
    do
      for SRD1_9_ = left, 1, -1 do
        r[SRD1_9_ + n] = op1[SRD1_9_]
      end
    end
  end
  return self:b2d(r)
end

function bit:_lshift(a, n)
  local op1 = self:d2b(a)
  local r = self:d2b(0)
  if n < 32 and n > 0 then
    do
      for SRD1_8_ = n, 31 do
        r[SRD1_8_ - n + 1] = op1[SRD1_8_ + 1]
      end
    end
  end
  return self:b2d(r, true)
end

function trim(s)
  return s:match("^%s*(.*)"):match("(.-)%s*$")
end

local json = {}
local kind_of = function(obj)
  if type(obj) ~= "table" then
    return type(obj)
  end
  local i = 1
  do
    do
      for SRD1_5_ in pairs(obj) do
        if obj[i] ~= nil then
          i = i + 1
        else
          return "table"
        end
      end
    end
  end
  if i == 1 then
    do return "table" end
    return
  end
  return "array"
end

local escape_str = function(s)
  local in_char = {
    "\\",
    "\"",
    "/",
    "\b",
    "\f",
    "\n",
    "\r",
    "\t"
  }
  local out_char = {
    "\\",
    "\"",
    "/",
    "b",
    "f",
    "n",
    "r",
    "t"
  }
  do
    do
      for SRD1_6_, SRD1_7_ in ipairs(in_char) do
        s = s:gsub(SRD1_7_, "\\" .. out_char[SRD1_6_])
      end
    end
  end
  return s
end

local skip_delim = function(str, pos, delim, err_if_missing)
  pos = pos + #str:match("^%s*", pos)
  if str:sub(pos, pos) ~= delim then
    if err_if_missing then
      error("Expected " .. delim .. " near position " .. pos)
    end
    return pos, false
  end
  return pos + 1, true
end

local function parse_str_val(str, pos, val)
  val = val or ""
  local early_end_error = "End of input found while parsing string."
  if pos > #str then
    error(early_end_error)
  end
  local c = str:sub(pos, pos)
  if c == "\"" then
    return val, pos + 1
  end
  if c ~= "\\" then
    return parse_str_val(str, pos + 1, val .. c)
  end
  local esc_map = {
    b = "\b",
    f = "\f",
    n = "\n",
    r = "\r",
    t = "\t"
  }
  local nextc = str:sub(pos + 1, pos + 1)
  if not nextc then
    error(early_end_error)
  end
  return parse_str_val(str, pos + 2, val .. (esc_map[nextc] or nextc))
end

local parse_num_val = function(str, pos)
  local num_str = str:match("^-?%d+%.?%d*[eE]?[+-]?%d*", pos)
  local val = tonumber(num_str)
  if not val then
    error("Error parsing number at position " .. pos .. ".")
  end
  return val, pos + #num_str
end

function json.stringify(obj, as_key)
  local s = {}
  local kind = kind_of(obj)
  if kind == "array" then
    if as_key then
      error("Can't encode array as key.")
    end
    s[#s + 1] = "["
    do
      do
        for SRD1_7_, SRD1_8_ in ipairs(obj) do
          if SRD1_7_ > 1 then
            s[#s + 1] = ", "
          end
          s[#s + 1] = json.stringify(SRD1_8_)
        end
      end
    end
    s[#s + 1] = "]"
  elseif kind == "table" then
    if as_key then
      error("Can't encode table as key.")
    end
    s[#s + 1] = "{"
    do
      do
        for SRD1_7_, SRD1_8_ in pairs(obj) do
          if #s > 1 then
            s[#s + 1] = ", "
          end
          s[#s + 1] = json.stringify(SRD1_7_, true)
          s[#s + 1] = ":"
          s[#s + 1] = json.stringify(SRD1_8_)
        end
      end
    end
    s[#s + 1] = "}"
  else
    if kind == "string" then
      do return "\"" .. escape_str(obj) .. "\"" end
      return
    end
    if kind == "number" then
      if as_key then
        return "\"" .. tostring(obj) .. "\""
      end
      do return tostring(obj) end
      return
    end
    if kind == "boolean" then
      do return tostring(obj) end
      return
    end
    if kind == "nil" then
      do return "null" end
      return
    end
    error("Unjsonifiable type: " .. kind .. ".")
  end
  return table.concat(s)
end

json.null = {}
function json.parse(str, pos, end_delim)
  pos = pos or 1
  if pos > #str then
    error("Reached unexpected end of input.")
  end
  local pos = pos + #str:match("^%s*", pos)
  local first = str:sub(pos, pos)
  if first == "{" then
    do
      local obj, key, delim_found = {}, true, true
      pos = pos + 1
      while true do
        key, pos = json.parse(str, pos, "}")
        if key == nil then
          return obj, pos
        end
        if not delim_found then
          error("Comma missing between object items.")
        end
        pos = skip_delim(str, pos, ":", true)
        obj[key], pos = json.parse(str, pos)
        pos, delim_found = skip_delim(str, pos, ",")
      end
    end
    return
  end
  if first == "[" then
    do
      local arr, val, delim_found = {}, true, true
      pos = pos + 1
      while true do
        val, pos = json.parse(str, pos, "]")
        if val == nil then
          return arr, pos
        end
        if not delim_found then
          error("Comma missing between array items.")
        end
        arr[#arr + 1] = val
        pos, delim_found = skip_delim(str, pos, ",")
      end
    end
    return
  end
  if first == "\"" then
    do return parse_str_val(str, pos + 1) end
    return
  end
  if first == "-" or first:match("%d") then
    do return parse_num_val(str, pos) end
    return
  end
  if first == end_delim then
    do return nil, pos + 1 end
    return
  end
  do
    local literals = {
      ["true"] = true,
      ["false"] = false,
      null = json.null
    }
    do
      do
        for SRD1_9_, SRD1_10_ in pairs(literals) do
          local lit_end = pos + #SRD1_9_ - 1
          if str:sub(pos, lit_end) == SRD1_9_ then
            return SRD1_10_, lit_end + 1
          end
        end
      end
    end
    local pos_info_str = "position " .. pos .. ": " .. str:sub(pos, pos + 10)
    error("Invalid json syntax starting at " .. pos_info_str)
  end
end

function enc(data, b)
  return (data:gsub(".", function(x)
    local r, b = "", x:byte()
    do
      do
        for SRD1_6_ = 8, 1, -1 do
          r = r .. (b % 2 ^ SRD1_6_ - b % 2 ^ (SRD1_6_ - 1) > 0 and "1" or "0")
        end
      end
    end
    return r
  end
  ) .. "0000"):gsub("%d%d%d?%d?%d?%d?", function(x)
    if #x < 6 then
      return ""
    end
    local c = 0
    do
      do
        for SRD1_5_ = 1, 6 do
          c = c + (x:sub(SRD1_5_, SRD1_5_) == "1" and 2 ^ (6 - SRD1_5_) or 0)
        end
      end
    end
    return b:sub(c + 1, c + 1)
  end
  ) .. ({
    "",
    "??",
    "?"
  })[#data % 3 + 1]
end

function dec(data, b)
  data = string.gsub(data, "[^" .. b .. "=]", "")
  return (data:gsub(".", function(x)
    if x == "?" then
      return ""
    end
    local r, f = "", b:find(x) - 1
    do
      do
        for SRD1_6_ = 6, 1, -1 do
          r = r .. (f % 2 ^ SRD1_6_ - f % 2 ^ (SRD1_6_ - 1) > 0 and "1" or "0")
        end
      end
    end
    return r
  end
  ):gsub("%d%d%d?%d?%d?%d?%d?%d?", function(x)
    if #x ~= 8 then
      return ""
    end
    local c = 0
    do
      do
        for SRD1_5_ = 1, 8 do
          c = c + (x:sub(SRD1_5_, SRD1_5_) == "1" and 2 ^ (8 - SRD1_5_) or 0)
        end
      end
    end
    return string.char(c)
  end
  ))
end

function xorDecrypt(key, data)
  local preData, result
  preData = ""
  result = ""
  local bit_key = bit:charCodeAt(key)
  do
    local c = 0
    local c2 = 1
    while c < #data and not (c >= #data) do
      preData = preData .. string.char(tonumber(string.sub(data, c2, c + 2), 16))
      c = c + 2
      c2 = c2 + 2
    end
  end
  local bit_data = bit:charCodeAt(preData)
  do
    local a = 0
    local b = 0
    while a < #preData do
      if b >= #key then
        b = 0
      end
      a = a + 1
      b = b + 1
      local xor = bit:_xor(bit_data[a], bit_key[b])
      if xor ~= nil and xor < 256 then
        result = result .. string.char(bit:_xor(bit_data[a], bit_key[b]))
      end
    end
  end
  return result
end

function decryptEhi(salt, data)
  data = dec(string.reverse(data), "RkLC2QaVMPYgGJW/A4f7qzDb9e+t6Hr0Zp8OlNyjuxKcTw1o5EIimhBn3UvdSFXs?")
  return xorDecrypt(salt, string.sub(data, 1, #data))
end

function decryptEhil(salt, data)
  data = dec(string.reverse(data), "t6uxKcTwhBn3UvRkLC2QaVM1o5A4f7Hr0Zp8OyjqzDb9e+dSFXsEIimPYgGJW/lN?")
  return xorDecrypt(salt, string.sub(data, 1, #data))
end

function rwmem(Address, SizeOrBuffer)
  assert(Address ~= nil, "[rwmem]: error, provided address is nil.")
  _rw = {}
  if type(SizeOrBuffer) == "number" then
    _ = ""
    do
      do
        for SRD1_5_ = 1, SizeOrBuffer do
          _rw[SRD1_5_] = {
            address = Address - 1 + SRD1_5_,
            flags = gg.TYPE_BYTE
          }
        end
      end
    end
    do
      do
        for SRD1_5_, SRD1_6_ in ipairs(gg.getValues(_rw)) do
          if SRD1_6_.value == 0 and limit == true then
            return _
          end
          _ = _ .. string.format("%02X", SRD1_6_.value & 255)
        end
      end
    end
    return _
  end
  Byte = {}
  SizeOrBuffer:gsub("..", function(x)
    Byte[#Byte + 1] = x
    _rw[#Byte] = {
      address = Address - 1 + #Byte,
      flags = gg.TYPE_BYTE,
      value = x .. "h"
    }
  end
  )
  gg.setValues(_rw)
end

function hexdecode(hex)
  return (hex:gsub("%x%x", function(digits)
    return string.char(tonumber(digits, 16))
  end
  ))
end

function hexencode(str)
  return (str:gsub(".", function(char)
    return string.format("%2x", char:byte())
  end
  ))
end

function Dec2Hex(nValue)
  nHexVal = string.format("%X", nValue)
  sHexVal = nHexVal .. ""
  return sHexVal
end

function ToInteger(number)
  return math.floor(tonumber(number) or error("Could not cast '" .. tostring(number) .. "' to number.'"))
end

function save(data)
  io.open(gg.EXT_STORAGE .. "/decrypt.txt", "w"):write(data)
  gg.toast("â•”â•â•â•—â”€â”€â”€â”€â”€â”€â”€â”€â”€â•”â•—\nâ•šâ•—â•—â• â•â•¦â•â•¦â•¦â•¦â•¦â•¦â•â•£â•šâ•—\nâ•”â•©â•â•‘â•©â•£â•â•£â•”â•£â•‘â•‘â•¬â•‘â•”â•£\nâ•šâ•â•â•©â•â•©â•â•©â•â• â•—â•‘â•”â•©â•â•\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â•šâ•â•©â•\nâ•”â•â•â•—â”€â”€â”€â”€â”€â”€â”€â•”â•â•¦â•â•—\nâ•‘â•â•â•¬â•¦â•¦â•â•¦â•â•¦â•â•£â•â•£â•â•¬â•¦â•¦â•—â•”â•—\nâ• â•â•â•‘â•‘â•‘â•â•£â•â•£â•©â•¬â•â•‘â•”â•£â•‘â•‘â•šâ•£â•šâ•—\nâ•šâ•â•â•©â•â•©â•â•©â•â•©â•â•©â•â•©â•â•šâ•â•©â•â•©â•â•")
end

function saveEhi(data)
  io.open(gg.EXT_STORAGE .. "/ehi.txt", "w"):write(data)
end

local ehi, configSalt
local Http = {}
function Http:New(data)
  ehi = data
  if data.configSalt == "" then
    configSalt = "EVZJNI"
  else
    configSalt = data.configSalt
  end
end

function Http:Dec(key)
  if ehi.configVersionCode > 10000 then
    if ehi[key] then
      do return decryptEhil(configSalt, ehi[key]) end
      return
    end
    do return "N/A" end
    return
  end
  if ehi[key] then
    do return decryptEhi(configSalt, ehi[key]) end
    return
  end
  return "N/A"
end

function Http:TunnelType()
  if ehi.tunnelType == "ssl_proxy_payload_ssh" then
    do return "SSH -> TLS/SSL + Proxy -> Custom Payload" end
    return
  end
  if ehi.tunnelType == "http_obfs_shadowsocks" then
    do return "Shadowsocks -> HTTP (Obfs)" end
    return
  end
  if ehi.tunnelType == "ssl_ssh" then
    do return "SSH -> TLS/SSL (stunnel)" end
    return
  end
  if ehi.tunnelType == "proxy_payload_ssh" then
    do return "SSH -> HTTP Proxy -> Custom Payload" end
    return
  end
  if ehi.tunnelType == "proxy_ssh" then
    do return "SSH -> HTTP Proxy" end
    return
  end
  if ehi.tunnelType == "direct_shadowsocks" then
    do return "Direct Shadowsocks" end
    return
  end
  if ehi.tunnelType == "direct_payload_ssh" then
    do return "SSH -> Direct -> Custom Payload" end
    return
  end

  if ehi.tunnelType == "dnstt_ssh" then
    do return "DNS (DNSTT) :  SSH" end
    return
  end 
  return ehi.tunnelType
end

local includes = function(tab, val)
  do
    do
      for SRD1_5_, SRD1_6_ in ipairs(tab) do
        if SRD1_6_ == val then
          return true
        end
      end
    end
  end
  return false
end

local ssh_mode = {
  "ssl_proxy_payload_ssh",
  "direct_payload_ssh",
  "proxy_payload_ssh",
  "proxy_ssh",
  "ssl_ssh"
}
function parseHttpInjector(data)
  local jsonData = json.parse(hexdecode(data))
  Http:New(jsonData)
  if includes(ssh_mode, ehi.tunnelType) then
      message = ""
      
      message = message .. "ğ„ğ’ğ“ğ„ğğ€ğğ™ğ—ğ— ğƒğ„ğ‚ğ‘ğ˜ğğ“ğğ‘\n"
      message = message .. "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n" 
      if ehi.overwriteServerData ~= "" then
      serverData = json.parse(ehi.overwriteServerData)
      message = message .. "[*] ServerEvozi : " .. serverData.name .. " (" .. serverData.ip .. ")\n"
      message = message .. "[*] PortEvozi : " .. serverData.sshPort .. " SSH " .. serverData.sshSslPort .. "\n"
      end
      message = message .. "[*] Hostname : " .. Http:Dec("host") .. "\n" 
      message = message .. "[*] Port : "  .. ehi.port .. "\n"
      message = message .. "[*] Username : "  .. Http:Dec("user") .. "\n"
      message = message .. "[*] Password : "  .. Http:Dec("password") .. "\n"
      message = message .. "[*] SNI : " .. Http:Dec("sniHostname") .. "\n"
      message = message .. "[*] Proxy : " .. Http:Dec("remoteProxy") .. "\n"
      message = message .. "[*] Payload : " .. Http:Dec("payload") .. "\n"
      message = message .. "[*] ToolsBy : @EstebanZxx\n" 
    gg.copyText(message, true)
    gg.toast(message .. "\nğ„ğ’ğ“ğ„ğğ€ğğ™ğ—ğ— ğƒğ„ğ‚ğ‘ğ˜ğğ“ğğ‘")
    saveEhi(message)
    
    
------------------------------------------------------------------------------------------------------------------------------------------------------------------
    
  
  elseif ehi.tunnelType == "dnstt_ssh" then
      message = ""
      
      message = message .. "ğ„ğ’ğ“ğ„ğğ€ğğ™ğ—ğ— ğƒğ„ğ‚ğ‘ğ˜ğğ“ğğ‘\n"
      message = message .. "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n" 
      message = message .. "[*] DNSType : " .. ehi.dnsType .. "\n"
      message = message .. "[*] DNSTTResolverAddress : " .. Http:Dec("dnsttDnsResolverAddr") .. "\n"
      message = message .. "[*] DNSTTResolverMode : " .. ehi.dnsttResolverMode .. "\n"
      message = message .. "[*] DNSTTResolverProvile : " .. ehi.dnsttResolverProfile .. "\n"
      if ehi.overwriteServerData ~= "" then
      serverData = json.parse(ehi.overwriteServerData)
      message = message .. "[*] ServerEvozi : " .. serverData.name .. " (" .. serverData.ip .. ")\n"
      message = message .. "[*] PortEvozi : " .. serverData.sshPort .. "SSH, " .. serverData.sshSslPort .. "\n"
      end
      message = message .. "[*] HostDNSTT : " .. Http:Dec("user") .. "\n"
      message = message .. "[*] PasswordDNSTT : " .. Http:Dec("password") .. "\n"
      message = message .. "[*] NameserverDNSTT : " .. Http:Dec("dnsttNameserver") .. "\n"
      message = message .. "[*] PubkeyDNSTT : " .. Http:Dec("dnsttPublicKey") .. "\n"
      message = message .. "[*] ToolsBy : @EstebanZxx\n" 
    gg.copyText(message, true)
    gg.toast(message .. "\nğ„ğ’ğ“ğ„ğğ€ğğ™ğ—ğ— ğƒğ„ğ‚ğ‘ğ˜ğğ“ğğ‘")
    saveEhi(message)
    
    
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------
    
    
elseif ehi.tunnelType == "direct_shadowsocks" then
      message = ""
      
      message = message .. "ğ„ğ’ğ“ğ„ğğ€ğğ™ğ—ğ— ğƒğ„ğ‚ğ‘ğ˜ğğ“ğğ‘\n"
      message = message .. "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n" 
      if ehi.overwriteServerData ~= "" then
      serverData = json.parse(ehi.overwriteServerData)
      message = message .. "[*] ServerEvozi : " .. serverData.name .. " (" .. serverData.ip .. ")\n"
      message = message .. "[*] PortEvozi : " .. serverData.sshPort .. "SSH, " .. serverData.sshSslPort .. "\n"
      end
      message = message .. "[*] ShadowsocksEncMethod : " .. ehi.shadowsocksEncryptionMethod .. "\n"
      message = message .. "[*] ShadowsocksHost : " .. Http:Dec("shadowsocksHost") .. "\n" 
      message = message .. "[*] ShadowsocksPassword : " .. Http:Dec("shadowsocksPassword") .. "\n" 
      message = message .. "[*] ShadowsocksPort : " .. ehi.shadowsocksPort .. "\n"
      message = message .. "[*] ToolsBy : @EstebanZxx\n" 
    gg.copyText(message, true)
    gg.toast(message .. "\nğ„ğ’ğ“ğ„ğğ€ğğ™ğ—ğ— ğƒğ„ğ‚ğ‘ğ˜ğğ“ğğ‘")
    saveEhi(message)
    
    
    
------------------------------------------------------------------------------------------------------------------------------------------------------------------

    
elseif ehi.tunnelType == "http_obfs_shadowsocks" then
      message = ""
      
      message = message .. "ğ„ğ’ğ“ğ„ğğ€ğğ™ğ—ğ— ğƒğ„ğ‚ğ‘ğ˜ğğ“ğğ‘\n"
      message = message .. "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n" 
       if ehi.overwriteServerData ~= "" then
      serverData = json.parse(ehi.overwriteServerData)
      message = message .. "[*] ServerEvozi : " .. serverData.name .. " (" .. serverData.ip .. ")\n"
      message = message .. "[*] PortEvozi : " .. serverData.sshPort .. "SSH, " .. serverData.sshSslPort .. "\n"
      end 
      message = message .. "[*] ShadowsocksEncMethod : " .. ehi.shadowsocksEncryptionMethod .. "\n"
      message = message .. "[*] ShadowsocksHost : " .. Http:Dec("shadowsocksHost") .. "\n" 
      message = message .. "[*] ShadowsocksPassword : " .. Http:Dec("shadowsocksPassword") .. "\n" 
      message = message .. "[*] ShadowsocksPort : " .. ehi.shadowsocksPort .. "\n"
      message = message .. "[*] HttpObfsSettings : " .. Http:Dec("httpObfsSettings") .. "\n" 
      message = message .. "[*] ToolsBy : @EstebanZxx\n" 
    gg.copyText(message, true)
    gg.toast(message .. "\nğ„ğ’ğ“ğ„ğğ€ğğ™ğ—ğ— ğƒğ„ğ‚ğ‘ğ˜ğğ“ğğ‘")
    saveEhi(message)


-----------------------------------------------------------------------------------------------------------------------------------------------------------------
         
     
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------  
 
  elseif ehi.tunnelType == "direct_v2r_vmess" then
    if ehi.v2rRawJson then
      v2json = Http:Dec("v2rRawJson")
      save(v2json)
      print("V2Ray Settings: /sdcard/decrypt.txt")
      gg.toast(message .. "\nğ„ğ’ğ“ğ„ğğ€ğğ™ğ—ğ— ğƒğ„ğ‚ğ‘ğ˜ğğ“ğğ‘")
      gg.copyText(v2json, true)
      gg.sleep(1)
      return
    end
    message = ""
    
    message = message .. "ğ„ğ’ğ“ğ„ğğ€ğğ™ğ—ğ— ğƒğ„ğ‚ğ‘ğ˜ğğ“ğğ‘\n"
    message = message .. "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n" 
    message = message .. "[*] Protocol : " .. Http:Dec("v2rProtocol") .. "\n"
    message = message .. "[*] Host : " .. Http:Dec("v2rHost") .. "\n"
    message = message .. "[*] Port : " .. Http:Dec("v2rPort") .. "\n"
    message = message .. "[*] UserID : " .. Http:Dec("v2rUserId") .. "\n"
    message = message .. "[*] AlterID : " .. Http:Dec("v2rAlterId") .. "\n"
    message = message .. "[*] Security : " .. Http:Dec("v2rVlessSecurity") .. "\n"
    if ehi.v2rNetwork and ehi.v2rNetwork ~= "" then
      message = message .. "[*] NetworkType : " .. Http:Dec("v2rNetwork") .. "\n"
    end
    if ehi.v2rWsHeader and ehi.v2rWsHeader ~= "" then
      message = message .. "[*] Header : " .. Http:Dec("v2rWsHeader") .. "\n"
    end
    if ehi.v2rWsPath and ehi.v2rWsPath ~= "" then
      message = message .. "[*] Path : " .. Http:Dec("v2rWsPath") .. "\n"
    end
    if ehi.v2rTlsSni and ehi.v2rTlsSni ~= "" then
      message = message .. "[*] SNI : " .. Http:Dec("v2rTlsSni") .. "\n"
    end
    message = message .. "[*] ToolsBy : @EstebanZxx\n" 
    gg.copyText(message, true)
    gg.toast(message .. "\nğ„ğ’ğ“ğ„ğğ€ğğ™ğ—ğ— ğƒğ„ğ‚ğ‘ğ˜ğğ“ğğ‘")
    saveEhi(message)
  end
  return (Menu)
end

-----------------------------------------------------------------------------------------------------
-- ğ‘ğğ¬ğ©ğğœğ­ ğ‚ğ«ğğšğ­ğ¨ğ«ğ¬. ğƒğ¨ğ§'ğ­ ğ‘ğğ¦ğ¨ğ¯ğ ğ‚ğ«ğğğ¢ğ­ ğŒğ¨ğğ®ğ¥ğğ¬..!!
-- ğ‚ğ¨ğğğ ğğ² : ğ„ğ’ğ“ğ„ğğ€ğ_ğ™ğ—ğ—
-----------------------------------------------------------------------------------------------------

function HTTPInjector()
  limit = true
  gg.clearResults()
  gg.setVisible(false)
  gg.setRanges(gg.REGION_C_ALLOC)
  gg.searchNumber("h 7B 22 63 6F 6E 66 69 67 45 78 70 69 72 79 54 69 6D 65 73 74", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1)
  if #r < 1 then
    gg.toast("âš  Metode 1 Gagal")
    hi_method2 = true
  end
  if hi_method2 then
    gg.searchNumber("h 7B 22 63 6F 6E 66 69 67 49 64 65 6E 74 69 66 69 65 72 22 3A", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      return (Menu)
    end
  end
  gg.searchNumber("h7B", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1000)
  readedMem = rwmem(r[1].address, 50000)
  save(hexdecode(readedMem))
  do
    do
      for SRD1_5_, SRD1_6_ in ipairs(r) do
        r[SRD1_5_].flags = gg.TYPE_FLOAT
        r[SRD1_5_].value = "1000"
      end
    end
  end
  gg.setValues(r)
  gg.clearResults()
  parseHttpInjector(readedMem)
end

-----------------------------------------------------------------------------------------------------
-- ğ‘ğğ¬ğ©ğğœğ­ ğ‚ğ«ğğšğ­ğ¨ğ«ğ¬. ğƒğ¨ğ§'ğ­ ğ‘ğğ¦ğ¨ğ¯ğ ğ‚ğ«ğğğ¢ğ­ ğŒğ¨ğğ®ğ¥ğğ¬..!!
-- ğ‚ğ¨ğğğ ğğ² : ğ„ğ’ğ“ğ„ğğ€ğ_ğ™ğ—ğ—
-----------------------------------------------------------------------------------------------------

function BypassPassword()
  limit = false
  function rwmem(Address, SizeOrBuffer)
    assert(Address ~= nil, "[rwmem]: error, provided address is nil.")
    _rw = {}
    if type(SizeOrBuffer) == "number" then
      _ = ""
      do
        do
          for _FORV_5_ = 1, SizeOrBuffer do
            _rw[_FORV_5_] = {
              address = Address - 1 + _FORV_5_,
              flags = gg.TYPE_BYTE
            }
          end
        end
      end
      do
        do
          for _FORV_5_, _FORV_6_ in ipairs(gg.getValues(_rw)) do
            if _FORV_6_.value == 0 and limit == true then
              return _
            end
            _ = _ .. string.format("%02X", _FORV_6_.value & 255)
          end
        end
      end
      return _
    end
    Byte = {}
    SizeOrBuffer:gsub("..", function(x)
      Byte[#Byte + 1] = x
      _rw[#Byte] = {
        address = Address - 1 + #Byte,
        flags = gg.TYPE_BYTE,
        value = x .. "h"
      }
    end
    )
    gg.setValues(_rw)
  end
  
  function hexdecode(hex)
    return (hex:gsub("%x%x", function(digits)
      return string.char(tonumber(digits, 16))
    end
    ))
  end
  
  function hexencode(str)
    return (str:gsub(".", function(char)
      return string.format("%2x", char:byte())
    end
    ))
  end
  
  function Dec2Hex(nValue)
    nHexVal = string.format("%X", nValue)
    sHexVal = nHexVal .. ""
    return sHexVal
  end
  
  function ToInteger(number)
    return math.floor(tonumber(number) or error("Could not cast '" .. tostring(number) .. "' to number.'"))
  end
  
  function save(data)
    local function hexencode_spasi(str)
      return (str:gsub(".", function(char)
          return string.format("%02x ", char:byte())
      end))
    end

    local function checkMatch(key, str)
      result = nil
      
      for index, value in ipairs(key) do
          result = str:match(value)
          if result then 
              break 
          end
      end
      
      return result
    end

    local function strip(s)
      return (s:gsub("^%s*(.-)%s*$", "%1"))
    end

    local function prosesData(data)

      local function findExpDate(tbl)
          local key = {
              "%d%d%d%d[\45]%d%d[\45]%d%d[\32]%d%d[\58]%d%d",
              "lifeTime"
          } 
          local result = nil
          
          for index_tbl, value_tbl in ipairs(tbl) do
  
              for index_key, value_key in ipairs(key) do
                  
                  if value_tbl:match(value_key) then
                      result = index_tbl
                  end
  
              end
          end
          return result
      end
  
      local function splitString(str, separator)
          local match_1, match_2 = str:match("(.-)"..separator.."(.*)")
          local tbl = {}
  
          no = 1
          while (match_2:match("(.-)"..separator.."(.*)") and no < 100) do
      
              match_1, match_2 = match_2:match("(.-)"..separator.."(.*)")
      
              if hexdecode(match_1):match("[^\x20]+") then
                  -- print(no.." : "..strip(hexdecode(match_1):gsub("[^\x20-\x7e]+","")))
                  table.insert(tbl, strip(hexdecode(match_1):gsub("[^\x20-\x7e]+","")))
              else 
                  -- print(no.." : KOSONG ANJING")
                  table.insert(tbl,"")
              end
              
              -- print()
              no = no + 1
              -- print(hexdecode(match_1):gsub("[^\x20-\x7e]+",""))
          end
  
          return tbl
      end
  
      local function fixedConfig(index, tbl)
          local result_fixedConfig = {}
          local beginIndex = index - 4
          local lastIndex = beginIndex + 31
  
          for i = beginIndex, lastIndex do
              table.insert(result_fixedConfig, tbl[i])
          end
  
          return result_fixedConfig
      end
      data = hexencode_spasi(data)
      data = data:gsub("00", "20")
      data = data:gsub("20", "z")
      data = data:gsub("66 61 6c 73 65", "F A L S E")
      data = data:gsub("\x20", "")
      data = data:gsub("\n", "")
      local separator = data:match("FALSE[\x7a]+(.-)[\x7a]+")
      data = data:gsub(separator, "0a56616c647947616e74656e67")
      separator = "0a56616c647947616e74656e67"
      data = data:gsub("z", "20")
      data = data:gsub("FALSE", "66616c7365")

      local result = splitString(data, separator)
      local assemblyPointIndex = findExpDate(result)
      local getConfig = fixedConfig(assemblyPointIndex, result)
  
      return getConfig
    end

    local function getOutput(tbl)
      local cfgRegex = {
        [22] = {
            ["name"] = "[*] ğğšğ¬ğ¬ğ°ğ¨ğ«ğğ•ğšğ¥ğ®ğğˆ",
            ["regex"] = "(.*)"
        },
        [23] = {
            ["name"] = "[*] ğğšğ¬ğ¬ğ°ğ¨ğ«ğğ•ğšğ¥ğ®ğğˆğˆ",
            ["regex"] = "(.*)"
        }
    }
      
      
            local message = "â•”â•â•—â”€â”€â•”â•â•¦â•â•—â”€â”€â”€â”€â”€â”€â”€â•”â•—â•”â•â•â•—â”€â”€â”€â”€â•”â•â•—\nâ•‘â•¬â• â•â•—â•‘â•â•£â•â•¬â•¦â•¦â•¦â•â•¦â•¦â•¦â•â•‘â•šâ•—â•”â•©â•¦â•â•¦â•—â•‘â•â•£\nâ•‘â•”â•£â•¬â•šâ•¬â•â• â•â•‘â•‘â•‘â•‘â•¬â•‘â•”â•£â•¬â•‘â”€â•‘â•‘â•¬â•‘â•¬â•‘â•šâ•¬â•â•‘\nâ•šâ•â•šâ•â•â•©â•â•©â•â•©â•â•â•©â•â•©â•â•šâ•â•â”€â•šâ•©â•â•©â•â•©â•â•©â•â•\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
  
      for index, value in ipairs(tbl) do
          
          if cfgRegex[index] and value:match(cfgRegex[index]["regex"]) then
              local namaKonten = cfgRegex[index]["name"]
              local valueRegexKonten = value:match(cfgRegex[index]["regex"])
  
              -- print(namaKonten.." â–º "..valueRegexKonten.."\n")
              message = message..namaKonten.." : "..valueRegexKonten.."\n"
          end
          
      end
  
      message = message.."â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
      return message
    end


    local contentToDecrypt = hexdecode(data)
    contentToDecrypt = prosesData(hexdecode(data))
    local hasil = getOutput(contentToDecrypt)
    io.open(gg.EXT_STORAGE .. "/decrypt.txt", "w"):write(data)
    gg.alert(hasil)
    gg.copyText(hasil, false)
    gg.toast("âœ“ Decrypt Success And Result Copied To Clipboard..!!")
  end
  
  gg.setRanges(gg.REGION_JAVA_HEAP)
  gg.searchNumber(":[splitPsiphon][splitPsiphon]", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1)
  if #r < 1 then
    gg.toast("âœ– Method 1 failed")
    hc_method2 = true
  end
  if hc_method2 then
    gg.searchNumber(":[splitPsiphon]", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("âœ– Method 2 failed")
      hc_method3 = true
    end
  end
  
  if hc_method3 then
    print("âœ– All methods failed")
    return (Menu)
  end
  local r = gg.getResults(11)
  if limit == false then
    r[1].address = r[1].address - 1000
  end
  readedMem = rwmem(r[1].address, 10000)
  save(readedMem)
  gg.clearResults()
end

function ManualDump()
function rwmem(Address, SizeOrBuffer)
  assert(Address ~= nil, "[rwmem]: error, provided address is nil.")
  _rw = {}
  if type(SizeOrBuffer) == "number" then
    _ = ""
    do
      do
        for i = 1, SizeOrBuffer do
          _rw[i] = {
            address = Address - 1 + i,
            flags = gg.TYPE_BYTE
          }
        end--ğƒğğœ ğğ² ğ€ğ¬ğ¡ğ«ğšğŸ(Fá´Ê€)
      end--ğƒğğœ ğğ² ğ€ğ¬ğ¡ğ«ğšğŸ(Dá´)
    end--ğƒğğœ ğğ² ğ€ğ¬ğ¡ğ«ğšğŸ(Dá´)
    do
      do
        for i, i in ipairs(gg.getValues(_rw)) do
          if i.value == 0 then
          end--ğƒğğœ ğğ² ğ€ğ¬ğ¡ğ«ğšğŸ(IÒ“)
          _ = _ .. string.format("%02X", i.value & 255)
        end--ğƒğğœ ğğ² ğ€ğ¬ğ¡ğ«ğšğŸ(Fá´Ê€)
      end--ğƒğğœ ğğ² ğ€ğ¬ğ¡ğ«ğšğŸ(Dá´)
    end--ğƒğğœ ğğ² ğ€ğ¬ğ¡ğ«ğšğŸ(Dá´)
    return _
  end--ğƒğğœ ğğ² ğ€ğ¬ğ¡ğ«ğšğŸ(IÒ“)
  Byte = {}
  SizeOrBuffer:gsub("..", function(x)
    Byte[#Byte + 1] = x
    _rw[#Byte] = {
      address = Address - 1 + #Byte,
      flags = gg.TYPE_BYTE,
      value = x .. "h"
    }
  end--ğƒğğœ ğğ² ğ€ğ¬ğ¡ğ«ğšğŸ(Fá´œÉ´á´„á´›Éªá´É´)
  )
  gg.setValues(_rw)
end--ğƒğğœ ğğ² ğ€ğ¬ğ¡ğ«ğšğŸ(Fá´œÉ´á´„á´›Éªá´É´)

local hexdecode = function(hex)
  return (hex:gsub("%x%x", function(digits)
    return string.char(tonumber(digits, 16))
  end--ğƒğğœ ğğ² ğ€ğ¬ğ¡ğ«ğšğŸ(Fá´œÉ´á´„á´›Éªá´É´)
  ))
end--ğƒğğœ ğğ² ğ€ğ¬ğ¡ğ«ğšğŸ(Fá´œÉ´á´„á´›Éªá´É´)

local hexencode = function(str)
  return (str:gsub(".", function(char)
    return string.format("%2x", char:byte())
  end--ğƒğğœ ğğ² ğ€ğ¬ğ¡ğ«ğšğŸ(Fá´œÉ´á´„á´›Éªá´É´)
  ))
end--ğƒğğœ ğğ² ğ€ğ¬ğ¡ğ«ğšğŸ(Fá´œÉ´á´„á´›Éªá´É´)

gg.clearResults()
options = gg.prompt({"Address"}, {
  [1] = ""
}, {
  [1] = "text"
})
gg.setRanges(gg.REGION_C_ALLOC)
readedMem = rwmem("0x" .. options[1], 70000)
io.open(gg.EXT_STORAGE .. "/decrypt.txt", "w"):write(hexdecode(readedMem))
gg.clearResults()
return (Menu)
end

-----------------------------------------------------------------------------------------------------
-- ğ‘ğğ¬ğ©ğğœğ­ ğ‚ğ«ğğšğ­ğ¨ğ«ğ¬. ğƒğ¨ğ§'ğ­ ğ‘ğğ¦ğ¨ğ¯ğ ğ‚ğ«ğğğ¢ğ­ ğŒğ¨ğğ®ğ¥ğğ¬..!!
-- ğ‚ğ¨ğğğ ğğ² : ğ„ğ’ğ“ğ„ğğ€ğ_ğ™ğ—ğ—
-----------------------------------------------------------------------------------------------------

while true do
  if gg.isVisible(true) then
    Lua = 1
    gg.setVisible(false)
    end
  if Lua == 1 then
    Irene()
    end
    end

-----------------------------------------------------------------------------------------------------
-- ğ‘ğğ¬ğ©ğğœğ­ ğ‚ğ«ğğšğ­ğ¨ğ«ğ¬. ğƒğ¨ğ§'ğ­ ğ‘ğğ¦ğ¨ğ¯ğ ğ‚ğ«ğğğ¢ğ­ ğŒğ¨ğğ®ğ¥ğğ¬..!!
-- ğ‚ğ¨ğğğ ğğ² : ğ„ğ’ğ“ğ„ğğ€ğ_ğ™ğ—ğ—
-----------------------------------------------------------------------------------------------------
